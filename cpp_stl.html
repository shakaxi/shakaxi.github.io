<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-02-15 Thu 01:00 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C++ - Standard Template Library (STL)</title>
<meta name="author" content="shaka" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="default.css"/>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">C++ - Standard Template Library (STL)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9fc7e6f">容器</a>
<ul>
<li><a href="#org6972c6b">顺序容器(sequential container)</a>
<ul>
<li><a href="#org3eb7b1e"><code>vector</code></a></li>
<li><a href="#org9b38963"><code>list</code> (双向链表)</a></li>
<li><a href="#orgd6c14e6"><code>forward_list</code> (单向链表)</a></li>
<li><a href="#orge41ca6d"><code>deque</code> (双头队列)</a></li>
<li><a href="#orgfa8fbe6"><code>array</code></a></li>
</ul>
</li>
<li><a href="#orgbd8c184">容器适配器(adaptor)</a>
<ul>
<li><a href="#org3904f2c"><code>queue</code></a></li>
<li><a href="#org78db338"><code>priority_queue</code></a></li>
<li><a href="#org6804b75"><code>stack</code></a></li>
</ul>
</li>
<li><a href="#orgfa17242">关联容器</a>
<ul>
<li><a href="#orgfcd62f1"><code>pair</code> 工具类</a></li>
<li><a href="#orga98a39d">排序关联容器或有序关联容器</a>
<ul>
<li><a href="#org284673c"><code>map</code> 和 <code>multimap</code></a></li>
<li><a href="#org19caae1"><code>set</code> 和 <code>multiset</code></a></li>
</ul>
</li>
<li><a href="#org431dfc6">无序关联容器或哈希表(hash table)</a></li>
</ul>
</li>
<li><a href="#org53111f2">其他容器</a></li>
</ul>
</li>
<li><a href="#org6a1bf93">算法</a>
<ul>
<li><a href="#orgd4789c0">绑定器(binder)</a></li>
<li><a href="#orgc3d8ae6">取反器(negator)</a></li>
<li><a href="#org56bea17">调用成员函数</a></li>
<li><a href="#org4f8d0b1">非修改序列算法</a>
<ul>
<li><a href="#orgfca61b7">搜索算法</a>
<ul>
<li><a href="#org9b5c547"><code>find</code> 和 <code>find_if</code></a></li>
</ul>
</li>
<li><a href="#org091d28b">比较算法</a></li>
<li><a href="#orgca10108">工具算法</a></li>
</ul>
</li>
<li><a href="#org29dc68e">修改序列算法</a>
<ul>
<li><a href="#orgc640a64">转换</a></li>
<li><a href="#org95b9901">复制</a></li>
<li><a href="#orgee79598">移动</a></li>
<li><a href="#org0996047">替换</a></li>
<li><a href="#org7962627">删除</a></li>
<li><a href="#orgda01900">唯一化</a></li>
<li><a href="#org51488c3">反转</a></li>
<li><a href="#org2a12234">乱序</a></li>
</ul>
</li>
<li><a href="#orgd6250ea">分区算法</a></li>
<li><a href="#org1b956ff">排序算法</a></li>
<li><a href="#org249b7f1">集合算法</a></li>
<li><a href="#org994734b">最大/最小算法</a></li>
<li><a href="#org5d879ae">数值处理算法</a></li>
<li><a href="#org9efb6b2"><code>accumulate</code></a></li>
<li><a href="#org79b5ff8"><code>std::function</code></a></li>
<li><a href="#orgc324b2e"><code>generate</code></a></li>
</ul>
</li>
<li><a href="#org6a5fa26">迭代器</a></li>
<li><a href="#org2cab417">不足</a></li>
</ul>
</div>
</div>
<p>
标准模板库(standard template library, STL)是C++标准库的子集, 其大量使用了模板.
</p>
<div id="outline-container-org9fc7e6f" class="outline-2">
<h2 id="org9fc7e6f">容器</h2>
<div class="outline-text-2" id="text-org9fc7e6f">
<ul class="org-ul">
<li>STL中的所有容器都是模板, 是泛型结构, 因此可以通过这些容器保存任意类型的数据. 除 <code>array</code> 和 <code>bitset</code> 外, 大部分STL容器的大小灵活多变, 都能自动增长或收缩, 以容纳更多或者更少的元素.</li>
<li>STL容器是同构的, 每个容器实例只允许一种类型的元素.</li>
<li>STL容器对元素使用值语义(value semantic)。因此，编写要用于STL的类时，一定要保证它们是可复制的。如果需要引用语义，必须自己实现。实现方法是保存元素指针，而不是保存元素本身。可以使用 <code>unique_ptr</code>, 使容器成为该指针所指对象的拥有者；或者使用 <code>shared_ptr</code>, 使容器与其他拥有者共享拥有权。</li>
<li>STL容器的一个模板类型参数是分配器(allocator)。该容器可以使用该分配器来为元素分配内存或释放内存。有些容器(例如 <code>map</code>)也接受将一个比较器(comparator)作为一个模板类型参数。比较器用作顺序元素。</li>
<li>所有的STL容器都包含了移动构造函数和移动赋值运算符, 从而实现了移动语义.</li>
<li>移动语义要正确地用于STL容器，必须把移动构造函数和移动复制运算符标记为 <code>noexcept</code>.</li>
<li>C++11在大部分STL容器中添加了对 <code>emplace</code> 操作的支持. <code>emplace</code> 的意思是放置到位, 就地构件对象.</li>
</ul>
</div>
<div id="outline-container-org6972c6b" class="outline-3">
<h3 id="org6972c6b">顺序容器(sequential container)</h3>
<div class="outline-text-3" id="text-org6972c6b">
<p>
顺序容器是元素的序列。
</p>
</div>
<div id="outline-container-org3eb7b1e" class="outline-4">
<h4 id="org3eb7b1e"><code>vector</code></h4>
<div class="outline-text-4" id="text-org3eb7b1e">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;vector&gt;</code> 中.</li>
<li>提供对元素的随机访问.</li>
<li>元素保存在连续的内存中.</li>
<li>能够在尾部快速插入和删除元素, 在其他部位插入和删除操作比较慢.</li>
<li>可以在本来需要使用数组的地方使用 <code>vector</code>.</li>
<li>在任何可能的情况下使用 <code>vector</code> 而不是C风格的数组.</li>
<li><code>vector</code> 的默认构造函数会创建一个带有0个元素的 <code>vector</code>. 此外, 还提供了一个可以指定元素数量的构造函数, 和同时指定元素数目和元素值的构造函数. 如果没有提供默认值, 那么新对象通过0初始化——将原始的整型类型初始化为0, 将原始浮点类型初始化为0.0, 将指针类型初始化为 <code>nullptr</code>.</li>
<li><code>vector</code> 存储对象的副本, 其析构函数调用每个对象的析构函数. <code>vector</code> 类的复制构造函数和赋值运算符对 <code>vector</code> 中的所有元素执行深度复制.</li>
<li><code>assign()</code> 方法删除所有现有的元素, 并添加任意数目的新元素.</li>
<li><code>swap()</code> 方法可以交换两个 <code>vector</code> 的内容.</li>
<li><code>vector</code> 的 <code>operator[]</code> 没有提供边界检查功能. C++标准指出通过 <code>operator[]</code> 访问边界外元素得到的结果是未定义的. 不同的是, <code>at()</code> 方法会执行边界检查, 越界会抛出异常(<code>out_of_range</code>).</li>
<li><code>front()</code> 和 <code>back()</code> 分别返回 <code>vector</code> 的第一个元素和最后一个元素的引用.</li>
<li><code>size()</code> 返回 <code>vector</code> 中元素的数目.</li>
<li><code>capacity()</code> 返回 <code>vector</code> 在重分配之前可以保存的元素个数. 因此, 在重分配之前还能插入的元素个数为 <code>capacity() - size()</code>.</li>
<li><code>resize()</code> 可以指定 <code>vector</code> 要保存的元素数目.</li>
<li><code>reserve()</code> 可以预分配空间.</li>
<li><code>push_back()</code> 可以向 <code>vector</code> 追加元素.</li>
<li><code>pop_back()</code> 可以删除 <code>vector</code> 最后一个元素. 注意, 该方法不会返回已删除的元素. 如果要访问这个元素, 必须首先通过 <code>back()</code> 获得这个元素.</li>
<li><code>insert()</code> 方法可以在 <code>vector</code> 中任意位置插入元素.</li>
<li><code>erase()</code> 方法可以在 <code>vector</code> 中任意位置删除元素.</li>
<li><code>clear()</code> 方法可以删除所有元素.</li>
</ul>
</div>
</div>
<div id="outline-container-org9b38963" class="outline-4">
<h4 id="org9b38963"><code>list</code> (双向链表)</h4>
<div class="outline-text-4" id="text-org9b38963">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;list&gt;</code> 中.</li>
<li>元素查找和访问很慢.</li>
<li>元素不一定保存在连续的内存中.</li>
<li>插入和删除很快.</li>
<li>不支持元素的随机访问, 访问元素的方法只有 <code>front()</code> 和 <code>back()</code>, 分别返回第一个元素和最后一个元素的引用. 访问其他的元素必须通过迭代器.</li>
<li>应该尽量使用 <code>list</code> 方法而不是泛型STL算法, 因为前者更高效.</li>
</ul>
</div>
</div>
<div id="outline-container-orgd6c14e6" class="outline-4">
<h4 id="orgd6c14e6"><code>forward_list</code> (单向链表)</h4>
<div class="outline-text-4" id="text-orgd6c14e6">
<ul class="org-ul">
<li>只支持前向迭代.</li>
<li>没有提供快速的随机访问.</li>
<li>内存需求比 <code>list</code> 小.</li>
</ul>
</div>
</div>
<div id="outline-container-orge41ca6d" class="outline-4">
<h4 id="orge41ca6d"><code>deque</code> (双头队列)</h4>
<div class="outline-text-4" id="text-orge41ca6d">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;deque&gt;</code> 中.</li>
<li>不要求元素保存在连续内存中.</li>
<li>提供了快速的元素访问.</li>
<li>在序列两端提供了快速的插入和删除(常量时间).</li>
<li>在序列中间插入和删除的速度较慢.</li>
<li>提供了 <code>push_front()</code>, <code>pop_front()</code> 和 <code>emplace_front()</code>.</li>
</ul>
</div>
</div>
<div id="outline-container-orgfa8fbe6" class="outline-4">
<h4 id="orgfa8fbe6"><code>array</code></h4>
<div class="outline-text-4" id="text-orgfa8fbe6">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;array&gt;</code> 中.</li>
<li>标准C风格数组的替代品, 实际上是对C风格数组的简单包装.</li>
<li>适合大小固定的集合. 不能增加或收缩.</li>
<li>没有提供插入和删除操作.</li>
<li>元素的访问速度极快.</li>
<li>要求两个模板参数: 第一个参数指定了元素类型; 第二个参数指定了元素的固定数量.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgbd8c184" class="outline-3">
<h3 id="orgbd8c184">容器适配器(adaptor)</h3>
<div class="outline-text-3" id="text-orgbd8c184">
<p>
容器适配器只是构建在某种标准顺序容器上的简单接口。
</p>
</div>
<div id="outline-container-org3904f2c" class="outline-4">
<h4 id="org3904f2c"><code>queue</code></h4>
<div class="outline-text-4" id="text-org3904f2c">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;queue&gt;</code> 中.</li>
<li>提供了标准的先入先出(FIFO)语义.</li>
<li>从一端插入元素, 从另一端取出元素.</li>
<li>插入元素和删除元素都很快.</li>
<li><code>push()</code> 和 <code>emplace()</code> 方法在 <code>queue</code> 尾部添加一个新元素</li>
<li><code>pop()</code> 移除头部元素.</li>
<li><code>front()</code> 和 <code>back()</code> 分别返回第一个元素和最后一个元素的引用, 而不会删除元素.</li>
</ul>
</div>
</div>
<div id="outline-container-org78db338" class="outline-4">
<h4 id="org78db338"><code>priority_queue</code></h4>
<div class="outline-text-4" id="text-org78db338">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;queue&gt;</code> 中.</li>
<li>插入删除比 <code>queue</code> 要慢.</li>
<li>其头元素的优先级最高。</li>
<li><code>push()</code> 和 <code>emplace()</code> 方法可以插入元素。</li>
<li><code>pop()</code> 可以删除元素。</li>
<li><code>top()</code> 可以返回头元素的const引用。</li>
<li>支持 <code>size()</code>, <code>empty</code> 和 <code>swap()</code> 方法。</li>
</ul>
</div>
</div>
<div id="outline-container-org6804b75" class="outline-4">
<h4 id="org6804b75"><code>stack</code></h4>
<div class="outline-text-4" id="text-org6804b75">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;stack&gt;</code> 中.</li>
<li>提供了标准的先入后出(FILO)语义，也称为后入先出语义.</li>
<li><code>push()</code> 在stack顶部添加一个新元素。</li>
<li><code>pop()</code> 从stack顶部删除一个元素。</li>
<li><code>top()</code> 返回顶部元素的引用。</li>
<li>最新插入的元素第一个被删除.</li>
<li>提供了快速的元素插入和删除.</li>
<li>支持 <code>size()</code>, <code>empty</code> 和 <code>swap()</code> 方法和标准的比较运算符。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfa17242" class="outline-3">
<h3 id="orgfa17242">关联容器</h3>
<div class="outline-text-3" id="text-orgfa17242">
<p>
关联容器是关联了键和值的容器。
</p>
</div>
<div id="outline-container-orgfcd62f1" class="outline-4">
<h4 id="orgfcd62f1"><code>pair</code> 工具类</h4>
<div class="outline-text-4" id="text-orgfcd62f1">
<ul class="org-ul">
<li><code>pair</code> 是一个类模板， 将两个可能属于不同类型的值组合起来。</li>
<li>通过 <code>first</code> 和 <code>second</code> 公共数据成员访问这两个值。</li>
<li>定义了 <code>operator==</code> 和 <code>operator&lt;</code> ， 用于比较 <code>first</code> 和 <code>second</code> 元素。</li>
<li>工具函数模板 <code>make_pair()</code> 用于从两个值构造一个 <code>pair</code> 。</li>
<li>在 <code>pair</code> 中使用一般指针是危险的，因为 <code>pair</code> 复制构造函数和赋值运算符只对指针类型进行浅复制和赋值。然而，在 <code>pair</code> 中保存 <code>shared_ptr</code> 这样的智能指针则是很安全的。</li>
</ul>
</div>
</div>
<div id="outline-container-orga98a39d" class="outline-4">
<h4 id="orga98a39d">排序关联容器或有序关联容器</h4>
<div class="outline-text-4" id="text-orga98a39d">
</div>
<div id="outline-container-org284673c" class="outline-5">
<h5 id="org284673c"><code>map</code> 和 <code>multimap</code></h5>
<div class="outline-text-5" id="text-org284673c">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;map&gt;</code> 中，保存的是键/值对。</li>
<li><code>map</code>
<ul class="org-ul">
<li>向 <code>map</code> 添加元素的方法是 <code>insert()</code> ，其允许判断键是否已经存在。该方法必须将键/值指定为 <code>pair</code> 对象或 <code>initializer_list</code> ，返回值为迭代器和布尔值组成的 <code>pair()</code> 。布尔值指示是否真的插入了新的键/值对，迭代器引用的是 <code>map</code> 中带有指定键的元素。如果指定的键已经存在，那么 <code>insert()</code> 不会改写元素值。</li>
<li><code>operator[]</code> 也可以插入元素。但是 <code>operator[]</code> 总是成功。如果给定键没有对应的元素值，就会创建带有对应键值的新元素。如果具有给定键的元素已经存在，那么 <code>operator[]</code> 会将元素值替换为新指定的值。</li>
<li><code>find()</code> 方法可以查找给定键值的元素。如果元素存在，这个方法返回指向具有指定键值的元素的迭代器；如果元素不存在，则返回 <code>end()</code> 迭代器。此外， <code>operator[]</code> 可以查找给定键值的元素，但是如果不知道元素是否存在，就不能使用 <code>operator[]</code> 。因为如果元素不存在， <code>operator[]</code> 就会插入一个包含相应键值的新元素。</li>
</ul></li>
<li><code>multimap</code>
<ul class="org-ul">
<li><code>multimap</code> 是一个允许多个元素使用同一个键值的 <code>map</code> 。</li>
<li><code>multimap</code> 不提供 <code>operator[]</code>. 其将所有带有同一个键值的元素保存在一起, 并提供了方法获得这个子范围的迭代器: <code>lower_bound()</code> 和 <code>upper_bound()</code> 方法分别返回满足给定键值的第一个元素和最后一个元素之后一个元素的迭代器. 如果没有元素匹配这个键值, 那么 <code>lower_bound()</code> 和 <code>upper_bound()</code> 相等. 此外, <code>equal_range()</code> 方法返回两个迭代器的 <code>pair</code>, 分别是 <code>lower_bound()</code> 和 <code>upper_bound()</code> 返回的迭代器.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org19caae1" class="outline-5">
<h5 id="org19caae1"><code>set</code> 和 <code>multiset</code></h5>
<div class="outline-text-5" id="text-org19caae1">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;set&gt;</code> 中。</li>
<li><code>multiset</code> 和 <code>set</code> 的关系等同于 <code>multimap</code> 和 <code>map</code> 的关系. <code>multiset</code> 支持 <code>set</code> 的所有操作, 但允许容器中同时保存多个相等的元素.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org431dfc6" class="outline-4">
<h4 id="org431dfc6">无序关联容器或哈希表(hash table)</h4>
<div class="outline-text-4" id="text-org431dfc6">
<ul class="org-ul">
<li><code>unordered_map</code> 和 <code>unordered_multimap</code> 定义在头文件 <code>&lt;unordered_map&gt;</code> 中, 都是类模板. <code>unordered_multimap</code> 是允许多个元素带有同一个键值的 <code>unordered_map</code>.</li>
<li><code>unordered_set</code> 和 <code>unordered_multiset</code> 定义在头文件 <code>&lt;unordered_set&gt;</code> 中. 二者分别类似于 <code>set</code> 和 <code>multiset</code>.</li>
<li>无序关联容器使用了哈希函数(hash function), 所以也称为哈希表.</li>
<li>哈希表的实现通常会使用某种形式的数组, 数组中的每个元素都称为桶(bucket).</li>
<li>哈希函数的结果未必是唯一的. 两个或多个键哈希到同一个桶索引, 称为冲突(collision).</li>
<li>C++标准为指针和所有基本数据类型(例如 <code>bool</code>, <code>char</code>, <code>int</code>, <code>float</code>, <code>double</code> 等)提供了哈希函数, 也为 <code>error_code</code>, <code>bitset</code>, <code>unique_ptr</code>, <code>shared_ptr</code>, <code>type_index</code>, <code>string</code>, <code>vector&lt;bool&gt;</code> 和 <code>thread</code> 提供了哈希函数.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org53111f2" class="outline-3">
<h3 id="org53111f2">其他容器</h3>
<div class="outline-text-3" id="text-org53111f2">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;bitset&gt;</code> 中的 <code>bitset</code> 并不是一个真正的STL容器: 固定大小(声明时指定大小), 不支持迭代器.</li>
<li><code>string</code> 也可看做字符的顺序容器.</li>
<li>STL提供了名为 <code>istream_iterator</code> 和 <code>ostream_iterator</code> 的特殊迭代器, 用于"遍历"输入和输出流.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6a1bf93" class="outline-2">
<h2 id="org6a1bf93">算法</h2>
<div class="outline-text-2" id="text-org6a1bf93">
<p>
算法之美在于算法不仅独立于底层元素的类型, 而且还独立于操作的容器的类型. 算法仅使用迭代器作为接口来操作容器, 而不是直接操作容器本身. 而对大部分容器来说, 迭代器范围都是半开半闭区间(包含第一个元素却不包含最后一个元素), 尾迭代器实际上是跨越最后一个元素(past-the-end)的标记. 大部分算法都接受回调(callback), 回调可以是一个函数指针, 也可以是行为上类似于函数指针的对象(例如重载了运算符 <code>operator()</code> 的对象, 或者内嵌lambda表达式). 为了方便起见, STL还提供了一组类, 用于创建算法使用的回调对象. 这些回调对象称为函数对象, 或仿函数(<code>functor</code>).
</p>

<ul class="org-ul">
<li>大部分算法定义在头文件 <code>&lt;algorithm&gt;</code> 中, 一些数值算法定义在头文件 <code>&lt;numeric&gt;</code> 中. 它们都在名称空间std中.</li>
<li>算法一般不属于容器的一部分. STL采取了一种分离数据(容器)和功能(算法)的方式. 正交性的指导原则使算法和容器分离开, (几乎)所有算法都可以用于(几乎)所有容器.</li>
<li>泛型算法并不是直接对容器操作, 而是使用迭代器(iterator). 迭代器是算法和容器之间的中介, 提供了顺序遍历容器中的元素的标准接口, 因此任何算法都可以操作任何容器.</li>
</ul>

<p>
函数适配器(function adaptor)对函数组合(function composition)提供了支持, 能够将函数组合在一起, 以精确提供所需的行为.
</p>
</div>
<div id="outline-container-orgd4789c0" class="outline-3">
<h3 id="orgd4789c0">绑定器(binder)</h3>
<div class="outline-text-3" id="text-orgd4789c0">
<p>
绑定器可用于将函数的参数绑定至特定的值. 为此要使用头文件 <code>&lt;functional&gt;</code> 中定义的 <code>std::bind()</code>. 它允许采用灵活的方式绑定函数的参数. 既可以将函数的参数绑定至固定值, 甚至还能够重新安排函数参数的顺序. <code>bind()</code> 函数的返回类型比较复杂, 但是可以使用 <code>auto</code> 关键字, 无须指定准确的返回类型. 没有绑定至指定值的参数应该标记为 <code>_1</code>, <code>_2</code>, 和 <code>_3</code> 等. 这些都定义在 <code>std::placeholders</code> 名称空间中.
</p>

<p>
头文件 <code>&lt;functional&gt;</code> 定义了辅助函数 <code>std::ref()</code> 和 <code>std::cref()</code>, 它们分别用于绑定引用和const引用.
</p>
</div>
</div>
<div id="outline-container-orgc3d8ae6" class="outline-3">
<h3 id="orgc3d8ae6">取反器(negator)</h3>
<div class="outline-text-3" id="text-orgc3d8ae6">
<p>
取反器是类似于绑定器的函数, 但是取反器计算谓词结果的反结果. 如果操作函数是一元函数, 需要使用 <code>not1()</code>; 如果操作函数是二元函数, 那么必须改用 <code>not2()</code>.
</p>
</div>
</div>
<div id="outline-container-org56bea17" class="outline-3">
<h3 id="org56bea17">调用成员函数</h3>
<div class="outline-text-3" id="text-org56bea17">
<p>
对于一个对象容器, 有时需要传递一个指向类方法的指针作为算法的回调. 但是算法无法知道接受的是指向方法的指针, 而不是普通函数指针或仿函数. 调用方法指针的代码和调用普通函数指针的代码是不一样的, 因为前者必须在对象的上下文内调用. C++提供了 <code>mem_fn()</code> 转换函数, 在传递给算法之前可以对函数指针调用这个函数.
</p>

<p>
如果容器内保存的不是对象本身, 而是对象指针, <code>mem_fn()</code> 的使用方法也完全一样.
</p>
</div>
</div>
<div id="outline-container-org4f8d0b1" class="outline-3">
<h3 id="org4f8d0b1">非修改序列算法</h3>
<div class="outline-text-3" id="text-org4f8d0b1">
</div>
<div id="outline-container-orgfca61b7" class="outline-4">
<h4 id="orgfca61b7">搜索算法</h4>
<div class="outline-text-4" id="text-orgfca61b7">
</div>
<div id="outline-container-org9b5c547" class="outline-5">
<h5 id="org9b5c547"><code>find</code> 和 <code>find_if</code></h5>
<div class="outline-text-5" id="text-org9b5c547">
<ul class="org-ul">
<li><code>find</code> 在一个迭代器范围内查找特定元素. 可将其用于任意容器类型的元素. 这个算法返回所找到元素的迭代器引用. 如果没有找到元素, 则返回迭代器范围的尾迭代器.</li>
<li>如果容器提供的方法具有与泛型算法同样的功能, 那么应该使用相应的方法, 那样速度更快.</li>
<li><code>find_if</code> 和 <code>find</code> 类似, 区别在于 <code>find_if</code> 接受谓词函数回调作为参数, 而不是简单地匹配元素. 谓词返回 <code>true</code> 或 <code>false</code>. <code>find_if</code> 算法对范围内的每个元素调用谓词, 直到谓词返回 <code>true</code>. 如果返回了 <code>true</code>, <code>find_if</code> 返回引用这个元素的迭代器引用.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org091d28b" class="outline-4">
<h4 id="org091d28b">比较算法</h4>
<div class="outline-text-4" id="text-org091d28b">
<p>
下列算法主要用于比较不同容器内的范围<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>.
</p>
<ul class="org-ul">
<li><code>equal()</code></li>
<li><code>mismatch()</code></li>
<li><code>lexicographical_compare()</code></li>
</ul>
</div>
</div>
<div id="outline-container-orgca10108" class="outline-4">
<h4 id="orgca10108">工具算法</h4>
<div class="outline-text-4" id="text-orgca10108">
<ul class="org-ul">
<li><code>all_of()</code></li>
<li><code>any_of()</code></li>
<li><code>none_of()</code></li>
<li><code>count()</code></li>
<li><code>count_if()</code></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org29dc68e" class="outline-3">
<h3 id="org29dc68e">修改序列算法</h3>
<div class="outline-text-3" id="text-org29dc68e">
<p>
修改算法通常返回一个引用目标范围最后一个值后一个位置(past-the-end)的迭代器.
</p>
</div>
<div id="outline-container-orgc640a64" class="outline-4">
<h4 id="orgc640a64">转换</h4>
<div class="outline-text-4" id="text-orgc640a64">
<ul class="org-ul">
<li><code>transform()</code> 算法对一个范围内的每个元素应用回调, 期望回调生成一个新元素, 并保存在指定的目标范围内. 如果希望 <code>transform()</code> 将范围内的每个元素替换为调用回调产生的结果, 那么源范围和目标范围可以是同一范围. 其参数是源序列的首尾迭代器, 目标序列的首迭代器和回调.</li>
<li><code>transform()</code> 的另一种形式对范围内的元素对调用二元回调, 它需要第一个范围内的首尾迭代器, 第二个范围的首迭代器和模板范围的首迭代器作为参数.</li>
</ul>
</div>
</div>
<div id="outline-container-org95b9901" class="outline-4">
<h4 id="org95b9901">复制</h4>
<div class="outline-text-4" id="text-org95b9901">
<ul class="org-ul">
<li><code>copy()</code> 算法可将一个范围内的元素复制到另一个范围中, 从范围中的第一个元素开始一直到最后一个元素. 源范围和目标范围必须不同, 但可以重叠.</li>
<li><code>copy()</code> 不会向目标范围插入元素, 只是改写已有的元素. 因此, 不能通过 <code>copy()</code> 直接向容器插入元素, 只能改写容器中已有的元素.</li>
<li><code>copy_backward()</code> 将源范围内的元素反向复制到目标范围内. 换句话说, 这个算法从源范围的最后一个元素开始, 将这个元素放在目标范围的最后一个位置, 然后在每一次复制之后反向移动.</li>
<li><code>copy_if()</code> 需要一个由两个迭代器指定的的输入范围, 由一个迭代器指定的输出目标, 以及一个谓词(函数或lambda表达式). 对每个准备复制的元素执行这个函数或lambda表达式. 如果返回值为true, 那么复制这个元素, 并且递增目标迭代器; 如果返回值为false, 那么不复制这个元素, 也不递增目标迭代器. 因此, 目标中包含的元素可能少于源范围. 对于一些容器来说, 由于肯定已经创建了足够的空间来保存最大可能数目的元素(要记住, 复制不会创建或扩大容器, 只是替换现有元素), 因此, 可能需要删除超出最后一个元素复制位置的空间. 为便于达到这个目的, <code>copy_if()</code> 返回了目标范围中最后一个复制的元素后一个位置(one-past-the-last-copied element)的迭代器, 以便确定需要从目标容器中删除的元素个数.</li>
<li><code>copy_n()</code> 从源范围复制n个元素到目标范围. 其第一个参数是起始迭代器, 第二个参数是一个指定要复制的元素个数的整数, 第三个参数为目标迭代器. 该算法不执行任何边界检查, 因此一定要确保起始迭代器递增了n个要复制的元素后, 不会超过集合的end(), 否则程序会产生未定义的行为.</li>
</ul>
</div>
</div>
<div id="outline-container-orgee79598" class="outline-4">
<h4 id="orgee79598">移动</h4>
<div class="outline-text-4" id="text-orgee79598">
<ul class="org-ul">
<li>有两个和移动相关的算法: <code>move()</code> 和 <code>move_backward()</code>. 它们都使用了移动语义. 如果要在自定义类型元素的容器中使用这些算法, 那么需要在元素类中提供移动赋值运算符.</li>
<li><code>move_backward()</code> 使用了和 <code>move()</code> 同样的移动机制, 但是按照从最后一个元素向第一个元素的顺序移动.</li>
</ul>
</div>
</div>
<div id="outline-container-org0996047" class="outline-4">
<h4 id="org0996047">替换</h4>
<div class="outline-text-4" id="text-org0996047">
<ul class="org-ul">
<li><code>replace()</code> 和 <code>replace_if()</code> 将一个范围中匹配某个值或满足某个谓词的元素替换为新的值. 比如 <code>replace_if()</code> 算法的前两个参数指定了容器中元素的范围. 第三个参数是一个返回true或false的函数或lambda表达式. 如果这个函数返回true, 那么容器中的对应值被替换为第四个参数指定的值; 如果返回false, 则保留原始值.</li>
<li><code>replace()</code> 也有称为 <code>replace_copy()</code> 和 <code>replace_copy_if()</code> 的变体, 这些变体将结果复制到不同的目标范围中. 它们类似于 <code>copy()</code>, 要求目标范围必须足够大, 以容纳新元素.</li>
</ul>
</div>
</div>
<div id="outline-container-org7962627" class="outline-4">
<h4 id="org7962627">删除</h4>
<div class="outline-text-4" id="text-org7962627">
<ul class="org-ul">
<li>算法只能访问迭代器抽象, 不能访问容器. 因此删除算法不能真正地从底层容器中删除元素, 而是把匹配给定值或谓词的元素替换为下一个不匹配给定值或谓词的元素. 结果是将集合分为两个集合: 一个用于保存要保留的元素, 另一个保存要删除的元素.</li>
<li>如果真的需要从容器中删除这些元素, 正确的解决方案为: 先使用 <code>remove()</code> 算法, 然后调用容器的 <code>erase()</code> 方法, 将从返回的迭代器到范围尾部的所有元素删除. 这就是 <b>删除-擦除法</b> (<b>remove-erase-idiom</b>).</li>
<li><code>remove()</code> 的 <code>remove_copy()</code> 和 <code>remove_copy_if()</code> 变体不会改变源范围, 而是将所有未删除的元素复制到另一个目标范围中. 这些算法和 <code>copy()</code> 类似, 要求目标范围必须足够大, 以便保存新元素.</li>
</ul>
</div>
</div>
<div id="outline-container-orgda01900" class="outline-4">
<h4 id="orgda01900">唯一化</h4>
<div class="outline-text-4" id="text-orgda01900">
<ul class="org-ul">
<li><code>unique()</code> 算法是特殊的 <code>remove()</code>, 将所有重复的连续元素删除. list容器提供了自己的具有同样语义的 <code>unique()</code> 方法.</li>
<li>通常情况下, 应该对有序序列使用 <code>unique()</code>, 但是 <code>unique()</code> 也能用于无序序列.</li>
<li><code>unique()</code> 的基本形式就地操作数据, 还有一个名为 <code>unique_copy()</code> 的版本, 其将结果复制到一个新的目标范围.</li>
</ul>
</div>
</div>
<div id="outline-container-org51488c3" class="outline-4">
<h4 id="org51488c3">反转</h4>
<div class="outline-text-4" id="text-org51488c3">
<ul class="org-ul">
<li><code>reverse()</code> 算法反转一个范围内元素的顺序. 范围内的第一个元素和最后一个元素交换, 第二个和倒数第二个交换, 依次类推.</li>
<li><code>reverse()</code> 最基本的形式就地运行, 要求两个参数: 范围的起始迭代器和终止迭代器.</li>
<li><code>reverse_copy()</code> 将结果复制到新的目标范围, 它需要三个参数: 源范围的首尾迭代器, 以及目标范围的起始迭代器. 目标范围必须足够大, 以便保存新元素.</li>
</ul>
</div>
</div>
<div id="outline-container-org2a12234" class="outline-4">
<h4 id="org2a12234">乱序</h4>
<div class="outline-text-4" id="text-org2a12234">
<ul class="org-ul">
<li><code>shuffle()</code> 以随机顺序重新安排范围内的元素, 其复杂度为线性时间. 它可以用于实现洗牌等任务.</li>
<li><code>shuffle()</code> 的参数为要乱序的范围的首尾迭代器, 和一个统一的随机数生成器对象, 它指定如何生成随机数.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd6250ea" class="outline-3">
<h3 id="orgd6250ea">分区算法</h3>
<div class="outline-text-3" id="text-orgd6250ea">
<ul class="org-ul">
<li><code>partition()</code> 算法给序列排序, 使谓词返回true的所有元素放在前面, 谓词返回false的所有元素放在后面, 在每个分区中不保留元素最初的顺序.</li>
<li><code>partition_copy()</code> 算法将一个来源的元素复制到两个不同的目标. 选择每个元素特定目标的依据是谓词的结果: true或false. 其返回值是一对迭代器: 一个迭代器引用第一个目标范围最后一个复制的元素的后一个位置(one-past-the-last-copied element), 另一个迭代器引用第二个目标范围最后一个复制的元素的后一个位置. 将这些返回的迭代器与 <code>erase()</code> 结合使用, 可以删除两个目标范围中多余的元素(与 <code>copy_if()</code> 类似).</li>
</ul>
</div>
</div>
<div id="outline-container-org1b956ff" class="outline-3">
<h3 id="org1b956ff">排序算法</h3>
<div class="outline-text-3" id="text-org1b956ff">
<ul class="org-ul">
<li>排序算法只能应用于顺序容器. 排序和关联容器无关, 因为关联容器已经维护了元素的顺序.</li>
<li>在一般情况下, 函数 <code>sort()</code> 在 $O(N\logN)$时间内将一个范围内的元素排序. 根据运算符 <code>operator&lt;</code>, 这个范围内的元素以非递减顺序排列(最小到最大). 如果不需要使用这个顺序, 可以指定一个不同的比较回调.</li>
<li><code>stable_sort()</code> 能够保持范围内相等元素的相对顺序, 所以效率比 <code>sort()</code> 低.</li>
</ul>
</div>
</div>
<div id="outline-container-org249b7f1" class="outline-3">
<h3 id="org249b7f1">集合算法</h3>
<div class="outline-text-3" id="text-org249b7f1">
<ul class="org-ul">
<li>集合算法可以用于任意有序的迭代器范围.</li>
<li><code>include()</code> 函数实现了标准的子集判断功能, 检查一个有序范围的所有元素是否包含在另一个有序范围中, 顺序任意.</li>
<li>下列算法实现了这些操作的标准语义
<ul class="org-ul">
<li><code>set_union()</code></li>
<li><code>set_intersection</code></li>
<li><code>set_difference</code></li>
<li><code>set_symmetric_difference</code></li>
</ul></li>
<li><code>merge()</code> 函数可将两个排好序的范围归并在一起, 并保持排序的顺序. 结果是一个包含两个源范围中所有元素的有序范围. 其复杂度为线性时间. 该算法需要以下参数
<ul class="org-ul">
<li>第一个源范围的起止迭代器.</li>
<li>第二个源范围的起止迭代器.</li>
<li>目标范围的起始迭代器.</li>
<li>比较回调(可选)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org994734b" class="outline-3">
<h3 id="org994734b">最大/最小算法</h3>
<div class="outline-text-3" id="text-org994734b">
<ul class="org-ul">
<li><code>min()</code> 和 <code>max()</code> 算法通过运算符 <code>operator&lt;</code> 或用户提供的二元谓词比较两个任意类型的元素, 分别返回一个引用较小或较大元素的const引用.</li>
<li><code>minmax()</code> 算法返回一个包含两个或更多元素中最小值和最大值的pair.</li>
</ul>
</div>
</div>
<div id="outline-container-org5d879ae" class="outline-3">
<h3 id="org5d879ae">数值处理算法</h3>
<div class="outline-text-3" id="text-org5d879ae">
<ul class="org-ul">
<li>头文件 <code>&lt;numeric&gt;</code> 中定义的 <code>inner_product()</code> 计算两个序列的内积.</li>
<li>头文件 <code>&lt;numeric&gt;</code> 中定义的 <code>iota()</code> 生成一个指定范围内的序列值, 从给定的值开始, 并应用 <code>operator++</code> 生成每个后续值.</li>
</ul>
<div class="org-src-container">
<pre class="src src-c++">...
vector&lt;int&gt; v(3);
iota(begin(v), end(v), 7); // v中元素的值依次为7, 8, 9.
...
</pre>
</div>
</div>
</div>
<div id="outline-container-org9efb6b2" class="outline-3">
<h3 id="org9efb6b2"><code>accumulate</code></h3>
<div class="outline-text-3" id="text-org9efb6b2">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;numeric&gt;</code> 中.</li>
<li>最基本形式是计算指定范围中元素的总和.</li>
<li>第二种形式允许指定要执行的操作, 而不是默认的加法操作. 这个操作的形式是二元回调.</li>
<li>最多有4个参数
<ol class="org-ol">
<li>开始迭代器</li>
<li>终止迭代器</li>
<li>初始值</li>
<li>函数回调或lambda表达式</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org79b5ff8" class="outline-3">
<h3 id="org79b5ff8"><code>std::function</code></h3>
<div class="outline-text-3" id="text-org79b5ff8">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;functional&gt;</code> 中. 可以用来创建指向函数, 函数对象或lambda表达式的类型.</li>
<li>语法为 <code>std::function&lt;R(ArgTypes...)&gt;</code>, 其中 <code>R</code> 是函数返回值的类型, <code>ArgTypes</code> 是一个逗号分隔的函数参数类型的列表.</li>
<li>从根本上来讲, <code>std::function</code> 是一个多态的函数对象包装(<b>多态函数包装器</b>), 类似于函数指针, 既可以当成函数指针来使用, 又可以用作实现回调的函数参数. 他可以绑定至任何能调用的对象(仿函数, 成员函数指针, 函数指针和lambda表达式), 只要参数和返回类型符合包装的类型即可.</li>
<li>由于 <code>std::function</code> 类型的行为和函数指针一致, 因此可以传递给STL算法.</li>
</ul>
</div>
</div>
<div id="outline-container-orgc324b2e" class="outline-3">
<h3 id="orgc324b2e"><code>generate</code></h3>
<div class="outline-text-3" id="text-orgc324b2e">
<p>
该算法需要一个迭代器范围, 它把该范围的值替换为从函数(第三个参数)返回的值.
</p>
</div>
</div>
</div>
<div id="outline-container-org6a5fa26" class="outline-2">
<h2 id="org6a5fa26">迭代器</h2>
<div class="outline-text-2" id="text-org6a5fa26">
<ul class="org-ul">
<li>STL通过迭代器模式提供了访问容器元素的泛型抽象. 每个容器都提供了容器特定的迭代器, 迭代器实际上是增强版的智能指针, 这种指针知道如何遍历特定容器的元素, 所有不同容器的迭代器都遵循C++标准中定义的特定接口.</li>
<li>迭代器的实现类似于智能指针类，因为它们都重载了特定的运算符。基本的迭代器操作类似于普通指针(dumb pointer)支持的操作, 因此普通指针可以合法用作特定容器的迭代器. 可以将迭代器想象为指向容器中某个元素的指针. 与指向数组元素的指针一样, 迭代器可以通过 <code>operator++</code> 移动到下一个元素. 还可以在迭代器上使用 <code>operator*</code> 和 <code>operator-&gt;</code> 来访问实际元素或元素中的字段. 有些迭代器支持通过 <code>operator==</code> 和 <code>operator!=</code> 进行比较, 还支持通过 <code>operator--</code> 转移到前一个元素.</li>
<li>所有迭代器都必须可以通过复制来构建，赋值，且可以析构。</li>
<li>可以使用 <code>std::distance()</code> 计算容器的两个迭代器之差。</li>
<li>只有顺序容器，关联容器和无序关联容器提供了迭代器，容器适配器和 <code>bitset</code> 类都不支持迭代元素。</li>
<li>STL中每个支持迭代器的容器类都为其迭代器类型提供了名为 <code>iterator</code> 和 <code>const_iterator</code> 的公共 <code>typedef</code> 。允许反向迭代元素的容器还提供了名为 <code>reverse_iterator</code> 和 <code>const_reverse_iterator</code> 的公共 <code>typedef</code> 。其中， <code>const_iterator</code> 和 <code>const_reverse_iterator</code> 提供了容器元素的只读访问。普通的 <code>iterator</code> 支持读和写, 可以转换为 <code>const_iterator</code>, 然而 <code>const_iterator</code> 不能转换为 <code>iterator</code>. 如果不需要修改容器中的元素, 那么应该使用 <code>const_iterator</code>.</li>
<li>容器的 <code>begin()</code> 方法返回容器中第一个元素的迭代器, <code>end()</code> 方法返回的迭代器是在容器中最后一个元素的迭代器上执行 <code>operator++</code> 后的结果. <code>begin()</code> 和 <code>end()</code> 在一起提供了一个左开右闭区间——包含第一个元素却不包含最后一个元素. 采用这种方式的原因是为了支持空容器——不包含任何元素的容器, 此时 <code>begin()</code> 等于 <code>end()</code>. 类似的还有返回 <code>const</code> 迭代器的 <code>cbegin()</code> 和 <code>cend()</code> 方法, 返回反向迭代器的 <code>rbegin()</code> 和 <code>rend()</code> 方法, 以及返回 <code>const</code> 反向迭代器的 <code>crbegin()</code> 和 <code>crend()</code> 方法. 标准库还支持全局非成员函数 <code>std::begin()</code> 和 <code>std::end()</code>, C++14又添加了 <code>std::cbegin()</code>, <code>std::cend</code>, <code>std::rbegin()</code>, <code>std::rend()</code>, <code>std::crbegin()</code>, <code>std::crend()</code>. 建议使用这些非成员函数, 而不是其成员函数.</li>
<li>只要可能, 尽量使用前递增而不要使用后递增, 因为前递增至少效率不会差, 一般更为高效. <code>iter++</code> 必须返回一个新的迭代器对象, 而 <code>++iter</code> 只是返回对 <code>iter</code> 的引用.</li>
</ul>
</div>
</div>
<div id="outline-container-org2cab417" class="outline-2">
<h2 id="org2cab417">不足</h2>
<div class="outline-text-2" id="text-org2cab417">
<ul class="org-ul">
<li>在通过多线程同时访问容器时, STL不能保证任何线程安全.</li>
<li>STL没有提供任何泛型的树结构或图结构.</li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
如果要比较两个同类型容器的元素, 可以使用运算符 <code>operator==</code> 和运算符 <code>operator&lt;</code>, 而不是 <code>equal()</code> 和 <code>lexicographical_compare()</code>.
</p></div></div>


</div>
</div></div>
</body>
</html>
