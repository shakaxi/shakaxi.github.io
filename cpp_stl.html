<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2018-04-21 Sat 21:17 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>C++ - Standard Template Library</title>
<meta name="generator" content="Org mode">
<meta name="author" content="shaka">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="default.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">C++ - Standard Template Library</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7209740">容器</a>
<ul>
<li><a href="#org1d78e86">顺序容器(sequential container)</a>
<ul>
<li><a href="#org9d972df"><code>vector</code></a></li>
<li><a href="#org15c6996"><code>list</code> (双向链表)</a></li>
<li><a href="#org8da7a92"><code>forward_list</code> (单向链表)</a></li>
<li><a href="#org14a1958"><code>deque</code> (双头队列)</a></li>
<li><a href="#orgcce71ea"><code>array</code></a></li>
</ul>
</li>
<li><a href="#org9275ee0">容器适配器(adaptor)</a>
<ul>
<li><a href="#org04d8e34"><code>queue</code></a></li>
<li><a href="#orgcee0c70"><code>priority_queue</code></a></li>
<li><a href="#org26fd690"><code>stack</code></a></li>
</ul>
</li>
<li><a href="#org33a8187">关联容器</a>
<ul>
<li><a href="#org4aae679"><code>pair</code> 工具类</a></li>
<li><a href="#orgaf1d10f">排序关联容器或有序关联容器</a>
<ul>
<li><a href="#org703102e"><code>map</code> 和 <code>multimap</code></a></li>
<li><a href="#org59bf8d9"><code>set</code> 和 <code>multiset</code></a></li>
</ul>
</li>
<li><a href="#orga7da342">无序关联容器或哈希表(hash table)</a></li>
</ul>
</li>
<li><a href="#org1d3ee42">其他容器</a></li>
</ul>
</li>
<li><a href="#org4c74286">算法</a></li>
<li><a href="#org6fd6dba">迭代器</a></li>
<li><a href="#org483f15e">不足</a></li>
</ul>
</div>
</div>
<p>
标准模板库(Standard Template Library, STL)是C++标准库的子集, 其大量使用了模板.
</p>
<div id="outline-container-org7209740" class="outline-2">
<h2 id="org7209740">容器</h2>
<div class="outline-text-2" id="text-org7209740">
<ul class="org-ul">
<li>STL中的所有容器都是模板, 是泛型结构, 因此可以通过这些容器保存任意类型的数据. 除 <code>array</code> 和 <code>bitset</code> 外, 大部分STL容器的大小灵活多变, 都能自动增长或收缩, 以容纳更多或者更少的元素.</li>
<li>STL容器是同构的, 每个容器实例只允许一种类型的元素.</li>
<li>STL容器对元素使用值语义(value semantic)。因此，编写要用于STL的类时，一定要保证它们是可复制的。如果需要引用语义，必须自己实现。实现方法是保存元素指针，而不是保存元素本身。可以使用 <code>unique_ptr</code>, 使容器成为该指针所指对象的拥有者；或者使用 <code>shared_ptr</code>, 使容器与其他拥有者共享拥有权。</li>
<li>STL容器的一个模板类型参数是分配器(allocator)。该容器可以使用该分配器来为元素分配内存或释放内存。有些容器(例如 <code>map</code>)也接受将一个比较器(comparator)作为一个模板类型参数。比较器用作顺序元素。</li>
<li>所有的STL容器都包含了移动构造函数和移动赋值运算符, 从而实现了移动语义.</li>
<li>移动语义要正确地用于STL容器，必须把移动构造函数和移动复制运算符标记为 <code>noexcept</code>.</li>
<li>C++11在大部分STL容器中添加了对 <code>emplace</code> 操作的支持. <code>emplace</code> 的意思是放置到位, 就地构件对象.</li>
</ul>
</div>
<div id="outline-container-org1d78e86" class="outline-3">
<h3 id="org1d78e86">顺序容器(sequential container)</h3>
<div class="outline-text-3" id="text-org1d78e86">
<p>
顺序容器是元素的序列。
</p>
</div>
<div id="outline-container-org9d972df" class="outline-4">
<h4 id="org9d972df"><code>vector</code></h4>
<div class="outline-text-4" id="text-org9d972df">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;vector&gt;</code> 中.</li>
<li>提供对元素的随机访问.</li>
<li>元素保存在连续的内存中.</li>
<li>能够在尾部快速插入和删除元素, 在其他部位插入和删除操作比较慢.</li>
<li>可以在本来需要使用数组的地方使用 <code>vector</code>.</li>
<li>在任何可能的情况下使用 <code>vector</code> 而不是C风格的数组.</li>
<li><code>vector</code> 的默认构造函数会创建一个带有0个元素的 <code>vector</code>. 此外, 还提供了一个可以指定元素数量的构造函数, 和同时指定元素数目和元素值的构造函数. 如果没有提供默认值, 那么新对象通过0初始化——将原始的整型类型初始化为0, 将原始浮点类型初始化为0.0, 将指针类型初始化为 <code>nullptr</code>.</li>
<li><code>vector</code> 存储对象的副本, 其析构函数调用每个对象的析构函数. <code>vector</code> 类的复制构造函数和赋值运算符对 <code>vector</code> 中的所有元素执行深度复制.</li>
<li><code>assign()</code> 方法删除所有现有的元素, 并添加任意数目的新元素.</li>
<li><code>swap()</code> 方法可以交换两个 <code>vector</code> 的内容.</li>
<li><code>vector</code> 的 <code>operator[]</code> 没有提供边界检查功能. C++标准指出通过 <code>operator[]</code> 访问边界外元素得到的结果是未定义的. 不同的是, <code>at()</code> 方法会执行边界检查, 越界会抛出异常(<code>out_of_range</code>).</li>
<li><code>front()</code> 和 <code>back()</code> 分别返回 <code>vector</code> 的第一个元素和最后一个元素的引用.</li>
<li><code>size()</code> 返回 <code>vector</code> 中元素的数目.</li>
<li><code>capacity()</code> 返回 <code>vector</code> 在重分配之前可以保存的元素个数. 因此, 在重分配之前还能插入的元素个数为 <code>capacity() - size()</code>.</li>
<li><code>resize()</code> 可以指定 <code>vector</code> 要保存的元素数目.</li>
<li><code>reserve()</code> 可以预分配空间.</li>
<li><code>push_back()</code> 可以向 <code>vector</code> 追加元素.</li>
<li><code>pop_back()</code> 可以删除 <code>vector</code> 最后一个元素. 注意, 该方法不会返回已删除的元素. 如果要访问这个元素, 必须首先通过 <code>back()</code> 获得这个元素.</li>
<li><code>insert()</code> 方法可以在 <code>vector</code> 中任意位置插入元素.</li>
<li><code>erase()</code> 方法可以在 <code>vector</code> 中任意位置删除元素.</li>
<li><code>clear()</code> 方法可以删除所有元素.</li>
</ul>
</div>
</div>
<div id="outline-container-org15c6996" class="outline-4">
<h4 id="org15c6996"><code>list</code> (双向链表)</h4>
<div class="outline-text-4" id="text-org15c6996">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;list&gt;</code> 中.</li>
<li>元素查找和访问很慢.</li>
<li>元素不一定保存在连续的内存中.</li>
<li>插入和删除很快.</li>
<li>不支持元素的随机访问, 访问元素的方法只有 <code>front()</code> 和 <code>back()</code>, 分别返回第一个元素和最后一个元素的引用. 访问其他的元素必须通过迭代器.</li>
<li>应该尽量使用 <code>list</code> 方法而不是泛型STL算法, 因为前者更高效.</li>
</ul>
</div>
</div>
<div id="outline-container-org8da7a92" class="outline-4">
<h4 id="org8da7a92"><code>forward_list</code> (单向链表)</h4>
<div class="outline-text-4" id="text-org8da7a92">
<ul class="org-ul">
<li>只支持前向迭代.</li>
<li>没有提供快速的随机访问.</li>
<li>内存需求比 <code>list</code> 小.</li>
</ul>
</div>
</div>
<div id="outline-container-org14a1958" class="outline-4">
<h4 id="org14a1958"><code>deque</code> (双头队列)</h4>
<div class="outline-text-4" id="text-org14a1958">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;deque&gt;</code> 中.</li>
<li>不要求元素保存在连续内存中.</li>
<li>提供了快速的元素访问.</li>
<li>在序列两端提供了快速的插入和删除(常量时间).</li>
<li>在序列中间插入和删除的速度较慢.</li>
<li>提供了 <code>push_front()</code>, <code>pop_front()</code> 和 <code>emplace_front()</code>.</li>
</ul>
</div>
</div>
<div id="outline-container-orgcce71ea" class="outline-4">
<h4 id="orgcce71ea"><code>array</code></h4>
<div class="outline-text-4" id="text-orgcce71ea">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;array&gt;</code> 中.</li>
<li>标准C风格数组的替代品, 实际上是对C风格数组的简单包装.</li>
<li>适合大小固定的集合. 不能增加或收缩.</li>
<li>没有提供插入和删除操作.</li>
<li>元素的访问速度极快.</li>
<li>要求两个模板参数: 第一个参数指定了元素类型; 第二个参数指定了元素的固定数量.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9275ee0" class="outline-3">
<h3 id="org9275ee0">容器适配器(adaptor)</h3>
<div class="outline-text-3" id="text-org9275ee0">
<p>
容器适配器只是构建在某种标准顺序容器上的简单接口。
</p>
</div>
<div id="outline-container-org04d8e34" class="outline-4">
<h4 id="org04d8e34"><code>queue</code></h4>
<div class="outline-text-4" id="text-org04d8e34">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;queue&gt;</code> 中.</li>
<li>提供了标准的先入先出(FIFO)语义.</li>
<li>从一端插入元素, 从另一端取出元素.</li>
<li>插入元素和删除元素都很快.</li>
<li><code>push()</code> 和 <code>emplace()</code> 方法在 <code>queue</code> 尾部添加一个新元素</li>
<li><code>pop()</code> 移除头部元素.</li>
<li><code>front()</code> 和 <code>back()</code> 分别返回第一个元素和最后一个元素的引用, 而不会删除元素.</li>
</ul>
</div>
</div>
<div id="outline-container-orgcee0c70" class="outline-4">
<h4 id="orgcee0c70"><code>priority_queue</code></h4>
<div class="outline-text-4" id="text-orgcee0c70">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;queue&gt;</code> 中.</li>
<li>插入删除比 <code>queue</code> 要慢.</li>
<li>其头元素的优先级最高。</li>
<li><code>push()</code> 和 <code>emplace()</code> 方法可以插入元素。</li>
<li><code>pop()</code> 可以删除元素。</li>
<li><code>top()</code> 可以返回头元素的const引用。</li>
<li>支持 <code>size()</code>, <code>empty</code> 和 <code>swap()</code> 方法。</li>
</ul>
</div>
</div>
<div id="outline-container-org26fd690" class="outline-4">
<h4 id="org26fd690"><code>stack</code></h4>
<div class="outline-text-4" id="text-org26fd690">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;stack&gt;</code> 中.</li>
<li>提供了标准的先入后出(FILO)语义，也称为后入先出语义.</li>
<li><code>push()</code> 在stack顶部添加一个新元素。</li>
<li><code>pop()</code> 从stack顶部删除一个元素。</li>
<li><code>top()</code> 返回顶部元素的引用。</li>
<li>最新插入的元素第一个被删除.</li>
<li>提供了快速的元素插入和删除.</li>
<li>支持 <code>size()</code>, <code>empty</code> 和 <code>swap()</code> 方法和标准的比较运算符。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org33a8187" class="outline-3">
<h3 id="org33a8187">关联容器</h3>
<div class="outline-text-3" id="text-org33a8187">
<p>
关联容器是关联了键和值的容器。
</p>
</div>
<div id="outline-container-org4aae679" class="outline-4">
<h4 id="org4aae679"><code>pair</code> 工具类</h4>
<div class="outline-text-4" id="text-org4aae679">
<ul class="org-ul">
<li><code>pair</code> 是一个类模板， 将两个可能属于不同类型的值组合起来。</li>
<li>通过 <code>first</code> 和 <code>second</code> 公共数据成员访问这两个值。</li>
<li>定义了 <code>operator==</code> 和 <code>operator&lt;</code> ， 用于比较 <code>first</code> 和 <code>second</code> 元素。</li>
<li>工具函数模板 <code>make_pair()</code> 用于从两个值构造一个 <code>pair</code> 。</li>
<li>在 <code>pair</code> 中使用一般指针是危险的，因为 <code>pair</code> 复制构造函数和赋值运算符只对指针类型进行浅复制和赋值。然而，在 <code>pair</code> 中保存 <code>shared_ptr</code> 这样的智能指针则是很安全的。</li>
</ul>
</div>
</div>
<div id="outline-container-orgaf1d10f" class="outline-4">
<h4 id="orgaf1d10f">排序关联容器或有序关联容器</h4>
<div class="outline-text-4" id="text-orgaf1d10f">
</div>
<div id="outline-container-org703102e" class="outline-5">
<h5 id="org703102e"><code>map</code> 和 <code>multimap</code></h5>
<div class="outline-text-5" id="text-org703102e">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;map&gt;</code> 中，保存的是键/值对。</li>
<li><code>map</code>
<ul class="org-ul">
<li>向 <code>map</code> 添加元素的方法是 <code>insert()</code> ，其允许判断键是否已经存在。该方法必须将键/值指定为 <code>pair</code> 对象或 <code>initializer_list</code> ，返回值为迭代器和布尔值组成的 <code>pair()</code> 。布尔值指示是否真的插入了新的键/值对，迭代器引用的是 <code>map</code> 中带有指定键的元素。如果指定的键已经存在，那么 <code>insert()</code> 不会改写元素值。</li>
<li><code>operator[]</code> 也可以插入元素。但是 <code>operator[]</code> 总是成功。如果给定键没有对应的元素值，就会创建带有对应键值的新元素。如果具有给定键的元素已经存在，那么 <code>operator[]</code> 会将元素值替换为新指定的值。</li>
<li><code>find()</code> 方法可以查找给定键值的元素。如果元素存在，这个方法返回指向具有指定键值的元素的迭代器；如果元素不存在，则返回 <code>end()</code> 迭代器。此外， <code>operator[]</code> 可以查找给定键值的元素，但是如果不知道元素是否存在，就不能使用 <code>operator[]</code> 。因为如果元素不存在， <code>operator[]</code> 就会插入一个包含相应键值的新元素。</li>
</ul></li>
<li><code>multimap</code>
<ul class="org-ul">
<li><code>multimap</code> 是一个允许多个元素使用同一个键值的 <code>map</code> 。</li>
<li><code>multimap</code> 不提供 <code>operator[]</code>. 其将所有带有同一个键值的元素保存在一起, 并提供了方法获得这个子范围的迭代器: <code>lower_bound()</code> 和 <code>upper_bound()</code> 方法分别返回满足给定键值的第一个元素和最后一个元素之后一个元素的迭代器. 如果没有元素匹配这个键值, 那么 <code>lower_bound()</code> 和 <code>upper_bound()</code> 相等. 此外, <code>equal_range()</code> 方法返回两个迭代器的 <code>pair</code>, 分别是 <code>lower_bound()</code> 和 <code>upper_bound()</code> 返回的迭代器.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org59bf8d9" class="outline-5">
<h5 id="org59bf8d9"><code>set</code> 和 <code>multiset</code></h5>
<div class="outline-text-5" id="text-org59bf8d9">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;set&gt;</code> 中。</li>
<li><code>multiset</code> 和 <code>set</code> 的关系等同于 <code>multimap</code> 和 <code>map</code> 的关系. <code>multiset</code> 支持 <code>set</code> 的所有操作, 但允许容器中同时保存多个相等的元素.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga7da342" class="outline-4">
<h4 id="orga7da342">无序关联容器或哈希表(hash table)</h4>
<div class="outline-text-4" id="text-orga7da342">
<ul class="org-ul">
<li><code>unordered_map</code> 和 <code>unordered_multimap</code> 定义在头文件 <code>&lt;unordered_map&gt;</code> 中, 都是类模板. <code>unordered_multimap</code> 是允许多个元素带有同一个键值的 <code>unordered_map</code>.</li>
<li><code>unordered_set</code> 和 <code>unordered_multiset</code> 定义在头文件 <code>&lt;unordered_set&gt;</code> 中. 二者分别类似于 <code>set</code> 和 <code>multiset</code>.</li>
<li>无序关联容器使用了哈希函数(hash function), 所以也称为哈希表.</li>
<li>哈希表的实现通常会使用某种形式的数组, 数组中的每个元素都称为桶(bucket).</li>
<li>哈希函数的结果未必是唯一的. 两个或多个键哈希到同一个桶索引, 称为冲突(collision).</li>
<li>C++标准为指针和所有基本数据类型(例如 <code>bool</code>, <code>char</code>, <code>int</code>, <code>float</code>, <code>double</code> 等)提供了哈希函数, 也为 <code>error_code</code>, <code>bitset</code>, <code>unique_ptr</code>, <code>shared_ptr</code>, <code>type_index</code>, <code>string</code>, <code>vector&lt;bool&gt;</code> 和 <code>thread</code> 提供了哈希函数.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1d3ee42" class="outline-3">
<h3 id="org1d3ee42">其他容器</h3>
<div class="outline-text-3" id="text-org1d3ee42">
<ul class="org-ul">
<li>定义在头文件 <code>&lt;bitset&gt;</code> 中的 <code>bitset</code> 并不是一个真正的STL容器: 固定大小(声明时指定大小), 不支持迭代器.</li>
<li><code>string</code> 也可看做字符的顺序容器.</li>
<li>STL提供了名为 <code>istream_iterator</code> 和 <code>ostream_iterator</code> 的特殊迭代器, 用于"遍历"输入和输出流.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4c74286" class="outline-2">
<h2 id="org4c74286">算法</h2>
<div class="outline-text-2" id="text-org4c74286">
<p>
算法之美在于算法不仅独立于底层元素的类型, 而且还独立于操作的容器的类型. 算法仅使用迭代器作为接口来操作容器, 而不是直接操作容器本身. 而对大部分容器来说, 迭代器范围都是半开半闭区间(包含第一个元素却不包含最后一个元素), 尾迭代器实际上是跨越最后一个元素(past-the-end)的标记. 大部分算法都接受回调(callback), 回调可以是一个函数指针, 也可以是行为上类似于函数指针的对象(例如重载了运算符 <code>operator()</code> 的对象, 或者内嵌lambda表达式). 为了方便起见, STL还提供了一组类, 用于创建算法使用的回调对象. 这些回调对象称为函数对象, 或仿函数(<code>functor</code>).
</p>

<ul class="org-ul">
<li>大部分算法定义在头文件 <code>&lt;algorithm&gt;</code> 中, 一些数值算法定义在头文件 <code>&lt;numeric&gt;</code> 中. 它们都在名称空间std中.</li>
<li>算法一般不属于容器的一部分. STL采取了一种分离数据(容器)和功能(算法)的方式. 正交性的指导原则使算法和容器分离开, (几乎)所有算法都可以用于(几乎)所有容器.</li>
<li>泛型算法并不是直接对容器操作, 而是使用迭代器(iterator). 迭代器是算法和容器之间的中介, 提供了顺序遍历容器中的元素的标准接口, 因此任何算法都可以操作任何容器.</li>
</ul>
</div>
</div>
<div id="outline-container-org6fd6dba" class="outline-2">
<h2 id="org6fd6dba">迭代器</h2>
<div class="outline-text-2" id="text-org6fd6dba">
<ul class="org-ul">
<li>STL通过迭代器模式提供了访问容器元素的泛型抽象. 每个容器都提供了容器特定的迭代器, 迭代器实际上是增强版的智能指针, 这种指针知道如何遍历特定容器的元素, 所有不同容器的迭代器都遵循C++标准中定义的特定接口.</li>
<li>迭代器的实现类似于智能指针类，因为它们都重载了特定的运算符。基本的迭代器操作类似于普通指针(dumb pointer)支持的操作, 因此普通指针可以合法用作特定容器的迭代器. 可以将迭代器想象为指向容器中某个元素的指针. 与指向数组元素的指针一样, 迭代器可以通过 <code>operator++</code> 移动到下一个元素. 还可以在迭代器上使用 <code>operator*</code> 和 <code>operator-&gt;</code> 来访问实际元素或元素中的字段. 有些迭代器支持通过 <code>operator==</code> 和 <code>operator!=</code> 进行比较, 还支持通过 <code>operator--</code> 转移到前一个元素.</li>
<li>所有迭代器都必须可以通过复制来构建，赋值，且可以析构。</li>
<li>可以使用 <code>std::distance()</code> 计算容器的两个迭代器之差。</li>
<li>只有顺序容器，关联容器和无序关联容器提供了迭代器，容器适配器和 <code>bitset</code> 类都不支持迭代元素。</li>
<li>STL中每个支持迭代器的容器类都为其迭代器类型提供了名为 <code>iterator</code> 和 <code>const_iterator</code> 的公共 <code>typedef</code> 。允许反向迭代元素的容器还提供了名为 <code>reverse_iterator</code> 和 <code>const_reverse_iterator</code> 的公共 <code>typedef</code> 。其中， <code>const_iterator</code> 和 <code>const_reverse_iterator</code> 提供了容器元素的只读访问。普通的 <code>iterator</code> 支持读和写, 可以转换为 <code>const_iterator</code>, 然而 <code>const_iterator</code> 不能转换为 <code>iterator</code>. 如果不需要修改容器中的元素, 那么应该使用 <code>const_iterator</code>.</li>
<li>容器的 <code>begin()</code> 方法返回容器中第一个元素的迭代器, <code>end()</code> 方法返回的迭代器是在容器中最后一个元素的迭代器上执行 <code>operator++</code> 后的结果. <code>begin()</code> 和 <code>end()</code> 在一起提供了一个左开右闭区间——包含第一个元素却不包含最后一个元素. 采用这种方式的原因是为了支持空容器——不包含任何元素的容器, 此时 <code>begin()</code> 等于 <code>end()</code>. 类似的还有返回 <code>const</code> 迭代器的 <code>cbegin()</code> 和 <code>cend()</code> 方法, 返回反向迭代器的 <code>rbegin()</code> 和 <code>rend()</code> 方法, 以及返回 <code>const</code> 反向迭代器的 <code>crbegin()</code> 和 <code>crend()</code> 方法. 标准库还支持全局非成员函数 <code>std::begin()</code> 和 <code>std::end()</code>, C++14又添加了 <code>std::cbegin()</code>, <code>std::cend</code>, <code>std::rbegin()</code>, <code>std::rend()</code>, <code>std::crbegin()</code>, <code>std::crend()</code>. 建议使用这些非成员函数, 而不是其成员函数.</li>
<li>只要可能, 尽量使用前递增而不要使用后递增, 因为前递增至少效率不会差, 一般更为高效. <code>iter++</code> 必须返回一个新的迭代器对象, 而 <code>++iter</code> 只是返回对 <code>iter</code> 的引用.</li>
</ul>
</div>
</div>
<div id="outline-container-org483f15e" class="outline-2">
<h2 id="org483f15e">不足</h2>
<div class="outline-text-2" id="text-org483f15e">
<ul class="org-ul">
<li>在通过多线程同时访问容器时, STL不能保证任何线程安全.</li>
<li>STL没有提供任何泛型的树结构或图结构.</li>
</ul>
</div>
</div>
</div>
</body>
</html>
