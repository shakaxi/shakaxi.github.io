#+TITLE: Git

* Introduction
/Git/ is a famous and powerful open-source software for version control and management. It was developed by Linus Torvalds with C programing language. What is different from /subversion/, git adopts a completely distributed manner. Regarding its utilization, besides its built-in manual, there is also an excellent book, /Pro Git/, which can be obtained for free[fn:1]. This post just summarizes the preliminary usage of git, which is referred from the book.
** Objects
In git, there are 3 types of objects defined, /blob/, /tree/, and /commit/. In order to view its properties, a dedicated command =git cat-file= is provided. Its type and content can be returned with option =-t= and =-p= respectively.
- A blob keeps the content of a binary compressed file.
- A tree represents a directory, including its hierarchy, permission, and the names of its componential files.
- A commit is essentially a SHA-1 hash.

A branch or a tag is nothing but a pointer pointing at the SHA-1 hash of a commit. Moreover, =HEAD= is also a pointer, which always points the active branch at the time.
** Areas
In the utilization of git, there are four important areas for storage, /workspace/, /index/ (or /stage/), /repository/ and /remote/. Their relationship can be illustrated by the figure below.
#+begin_src dot :file git.png
  digraph G
  {
  rankdir = LR;
  workspace -> index [label = "add"];
  index -> repository [label = "commit"];
  repository -> remote [label = "push"];
  remote -> repository [label = "fetch/clone"];
  repository -> workspace [label = "checkout"];
  remote -> workspace [label = "pull"];
  workspace [style = filled, color = yellow];
  index [label = "index/stage", style = filled, color = lightblue];
  repository [style = filled, color = green];
  remote [style = filled, color = red];
  }
#+end_src

#+RESULTS:
[[file:git.png]]
* Installation
On Unix/Linux operation systems, git can be easily installed. Taking /ArchLinux/ for instance, git can be installed via following command.
#+begin_src sh
  pacman -S git
#+end_src
In order to enable bash-like auto completion, add following entry to =~/.bashrc=
#+begin_src sh
  source /usr/share/git/completion/git-completion.bash
#+end_src
For GUI, package /tk/ needs to be installed additionally.
#+begin_src sh
  pacman -S tk
#+end_src
* Configuration
Command =git config= can define the default preference or behavior of git. There are several files this command will read from and write to so we can set values globally or repository-specifically.
- List the per-repository/per-user/system-wide configuration.
#+begin_src sh
  git config --list [--global/--system]
#+end_src
- Per-repository/per-user/system-wide configuration
#+begin_src sh
  git config -e [--global/--system]
  git config [--global/--system] user.name "NAME"
  git config [--global/--system] user.email "EMAIL@COMPANY.COM"
#+end_src
- Store password to avoid repeated password input.
#+begin_src sh
  git config [--global/--system] credential.helper store
#+end_src
- Define default editor.
#+begin_src sh
  git config [--global/--system] core.editor "emacs -nw"
#+end_src
* Usage
** Create repositories
- Create an empty repository (=git init= can also reinitialize an existing repository).
#+begin_src sh
  git init /PATH/TO/REPOSITORY
#+end_src
- Initialize the current directory as a repository.
#+begin_src sh
  git init
#+end_src
- Download from a remote repository. Option =--bare= can be used for a repository without workspace.
#+begin_src sh
  git clone [--bare] /PATH/TO/REPOSITORY.git
  git clone [--bare] file:///PATH/TO/REPOSITORY.git
  git clone [--bare] http://SERVER:PORT/PATH/TO/REPOSITORY.git
  git clone [--bare] https://SERVER:PORT/PATH/TO/REPOSITORY.git
  git clone [--bare] USER@SERVER:/PATH/TO/REPOSITORY.git
#+end_src
** Basic snapshotting
*** Add file(s)
- Add the content from the workspace into index area for the next commit.
#+BEGIN_SRC sh
  git add FILE1 [FILE2]
  git add DIRECTORY
#+END_SRC
- Add the revisions for the already tracked files.
#+begin_src sh
  git add -u
#+end_src
*** Remove file(s)
- Stop tracking file(s).
#+begin_src sh
  git rm --cached FILE1 [FILE2]
#+end_src
- Remove file(s) in workspace and index the removal in index.
#+begin_src sh
  git rm FILE1 [FILE2]
#+end_src
*** Commit the revision(s)
The commands take the all/or the specific file(s) that have been staged with =git add= and record a new permanent snapshot in the repository and then moves the branch pointer on the current branch up to it.
- Commit all the files in the index.
#+begin_src sh
  git commit [-m MESSAGE]
#+end_src
- Commit specific file(s) in the index.
#+begin_src sh
  git commit FILE1 [FILE2] [-m MESSAGE]
#+end_src
- Replace the last commit with the new commit. If no changes for the codes compared to the last commit, only commit message will be updated.
#+begin_src sh
  git commit --amend [-m MESSAGE]
  git commit --amend [FILE]
#+end_src
*** Branch operations
- List all the local/remote branches.
#+begin_src sh
  git branch [-r]
#+end_src
- List all the branches including both local and remote ones.
#+begin_src sh
  git branch -a
#+end_src
- Create a new branch pointing to a given commit. If not provided, the initial pointing of the new branch is =HEAD=.
#+begin_src sh
  git branch BRANCH_NAME [COMMIT_NAME]
#+end_src
- Switch to an existing branch.
#+begin_src sh
  git checkout BRANCH_NAME
#+end_src
- Create a new branch and switch to it.
#+begin_src sh
  git checkout -b BRANCH_NAME [REMOTE_NAME/REMOTE_BRANCH_NAME]
#+end_src
- Associate a local branch to a remote branch.
#+begin_src sh
  git branch --set-upstream LOCAL_BRANCH_NAME REMOTE_NAME/REMOTE_BRANCH_NAME
#+end_src
- Create a new branch and associate it to a remote branch.
#+begin_src sh
  git branch --track BRANCH_NAME REMOTE_NAME/REMOTE_BRANCH_NAME
  git fetch remote_name remote_branch_name:branch_name
#+end_src
- Merge a given branch into the current branch.
#+begin_src sh
  git merge -m MESSAGE BRANCH_NAME
#+end_src
Git labels the difference between branches, e.g.,
#+begin_src sh
  ...
  <<<<<<< HEAD
  ABCDEFG
  =======
  abcdefg
  >>>>>>> branch_name
  ...
#+end_src
In this case, manual merge (edit) is necessary. After that, add the merged files into index area (=git add=) and commit them (=git commit=). At the stage of merge, if possible, git always tries to merge branches using =fast forward= by default. However, it can be disabled by option =--no-ff=, i.e.,
#+begin_src sh
  git merge [--no-ff] BRANCH_NAME
#+end_src
Clearly, =git merge= will keep the history of a series of commits and produce a new commit; while =git rebase= will guarantee a linear commit history without generating any new commits.
- Cherry-pick can pick/merge the revisions of one or more commits into the current branch.
  #+begin_src sh
    git cherry-pick COMMIT_HASH
  #+end_src
- Rebase is another operation to merge branch, which moves the revisions in the current branch to a target branch. Compared to =merge=, =rebase= has linear and clear commit history.
  #+begin_src sh
    git rebase BRANCH_NAME
  #+end_src
- Remove a local branch.
#+begin_src sh
  git branch -d BRANCH_NAME
#+end_src
- Remove a local (not merged) branch forcely.
#+begin_src sh
  git branch -D BRANCH_NAME
#+end_src
- Remove a remote branch.
#+begin_src sh
  git push origin --delete BRANCH_NAME
  git branch -dr REMOTE_NAME/BRANCH_NAME
#+end_src
*** Rebase
Taking rebasing the current branch, e.g. =BRANCH_NAME=, onto a target, e.g. =master= branch, for instance, a basic work flow for =git rebase= can be listed as follows.
#+begin_src sh
  # Switch to branch BRANCH_NAME.
  git checkout BRANCH_NAME

  # Rebase the related commits onto master branch.
  git rebase master

  # For any conflicts, several cycles of following steps are indispensable.
  # 1) Resolve the conflicts manually.
  # 2) Add the revised files by "git add".
  # 3) Continue the rebasing operation by "git rebase --continue" until all the conflicts resolved.

  # Switch back to master branch.
  git checkout master

  # Merge BRANCH_NAME into master in a fast-forward way.
  git merge BRANCH_NAME
#+end_src

An interactive interface is available if option =-i= is given whereby a variety of operations can be completed, e.g., =pick=, =reword=, =edit=, =squash=, =fixup=, =exec=, =drop=.
#+begin_src sh
  git rebase -i PARENT_OF_EARLIEST_COMMIT_INVOLVED
#+end_src
#+caption: Commands in rebase
#+attr_html: :align center :border 3
| Command  | Operation                                                                  |
|----------+----------------------------------------------------------------------------|
| =pick=   | Add a commit without any modification.                                     |
| =squash= | Combine multiple commits into a single one with a new commit message.      |
| =fixup=  | Combine multiple commits into a single one but keeping the commit message. |
| =edit=   | Add more changes to an existing commit.                                    |
| =reword= | Change the commit message only.                                            |
| =drop=   | Delete a commit.                                                           |
*** Tag operations
- List all tags.
#+begin_src sh
  git tag
#+end_src
- Create a new tag for a commit. If not provided, the tag is labeled on =HEAD=.
#+begin_src sh
  git tag TAG_NAME COMMIT_NAME
#+end_src
- Remove a tag.
#+begin_src sh
  git tag -d TAG_NAME
#+end_src
- Remove a remote tag.
#+begin_src sh
  git tag -d TAG_NAME
  git push origin :refs/tags/TAG_NAME
#+end_src
- Show information of a tag.
#+begin_src sh
  git show TAG_NAME
#+end_src
- Commit a tag.
#+begin_src sh
  git push REMOTE_NAME TAG_NAME
#+end_src
- Commit all tags.
#+begin_src sh
  git push REMOTE_NAME --tags
#+end_src
- Create a new branch pointing to a tag.
#+begin_src sh
  git checkout -b BRANCH_NAME TAG_NAME
#+end_src
*** Information query
- Show revised file(s) in workspace compared to those in index.
#+begin_src sh
  git status
#+end_src
- Show the revisions in a commit.
#+begin_src sh
  git show COMMIT_NAME
#+end_src
- Show the history of current branch (option =--stat= can list the revised files, and option =--graph= can show the merging of branches).
#+begin_src sh
  git log [--stat] [--graph]
#+end_src
- List the command record.
#+begin_src sh
  git reflog
#+end_src
- Show the modifier and time of a file.
#+begin_src sh
  git blame FILE_NAME
#+end_src
*** Show the difference
- Show the difference between the workspace and the index.
#+begin_src sh
  git diff
#+end_src
- Show the difference between the index and =HEAD=.
#+begin_src sh
  git diff --cached/--staged
#+end_src
- Show the difference between two commits.
#+begin_src sh
  git diff COMMIT1 COMMIT2
#+end_src
*** Remote operation
- List all the remote repositories.
#+begin_src sh
  git remote [-v]
#+end_src
- Show the information of a remote repository.
#+begin_src sh
  git remote show REMOTE_NAME
#+end_src
- Add a remote repository.
#+begin_src sh
  git remote add REMOTE_ALIAS REMOTE_URL
#+end_src
- Remove a remote repository.
#+begin_src sh
  git remote remove REMOTE_ALIAS
#+end_src
- Download all the commit records from a remote repository.
#+begin_src sh
  git fetch REMOTE_NAME
#+end_src
- Download all the commit records from a remote repository and merge it into the current local branch. In this sense, =git pull = git fetch + git merge=.
#+begin_src sh
  git pull REMOTE_NAME REMOTE_BRANCH_NAME
#+end_src
- Download all the commit records from a remote repository and rebase the current local branch onto it. Similarly, =git pull --rebase = git fetch + git rebase=.
#+begin_src sh
  git pull --rebase REMOTE_NAME REMOTE_BRANCH_NAME
#+end_src
- Upload the local branch to a remote repository. If not provided, it will push to =master= of =origin=.
#+begin_src sh
  git push REMOTE_NAME REMOTE_BRANCH_NAME
#+end_src
- Upload all the local branches to a remote repository.
#+begin_src sh
  git push REMOTE_NAME --all
#+end_src
*** Undo operation
- Recover the workspace from index.
#+begin_src sh
  git checkout -- [FILE]
#+end_src
- Recover the workspace from a commit.
#+begin_src sh
  git checkout COMMIT_NAME [FILE]
#+end_src
- Recover index from a commit.
#+begin_src sh
  git reset COMMIT_NAME
#+end_src
- Recover index and workspace from a commit.
#+begin_src sh
  git reset --hard COMMIT_NAME
#+end_src
- Move pointer =HEAD= to a commit.
#+begin_src sh
  git reset --keep COMMIT_NAME
#+end_src
** Temporary switch
- Buffer the workspace temporarily.
#+begin_src sh
  git stash
#+end_src
- List the buffered workspace.
#+begin_src sh
  git stash list
#+end_src
- Recover the buffered workspace.
#+begin_src sh
  git stash apply
#+end_src
- Remove the buffer or the buffered workspace.
#+begin_src sh
  git stash drop
#+end_src
- Recover the buffered workspace and remove the buffer.
#+begin_src sh
  git stash pop
#+end_src
** Submodule
As its name implies, a submodule is a relatively independent feature which can be imported from another repository. The information relating to a submodule is scattered in following 3 places.
- File =.gitmodules=
#+begin_src sh
  [submodule "/PATH/TO/SUBMODULE"]
          path = PATH/TO/SUBMODULE
          url = SUBMODULE_REPOSITORY_URL
          branch = BRANCH_NAME
#+end_src
- File =.git/config=
#+begin_src sh
  [submodule "/PATH/TO/SUBMODULE"]
          url = SUBMODULE_REPOSITORY_URL
#+end_src
- Directory =.git/modules/PATH/TO/SUBMODULE=

Moreover, a submodule can further consist of one or more subsubmodule(s). A recursive operation can be performed by option =--recursive=.
*** Usage
- Add a submodule to the current repository, with =/PATH/TO/SUBMODULE= as the relative location for the submodule, and =SUBMODULE_NAME= as its name.
  #+begin_src sh
    git submodule add [-b|--branch BRANCH_NAME] [-f|--force] [--name SUBMODULE_NAME] [--depth N] SUBMODULE_REPOSITORY_URL /PATH/TO/SUBMODULE
  #+end_src
- Register an added submodule, i.e., add a new section in =.git/config= using the corresponding section in =.gitmodules= as a template. For each registered submodule, further calls to =git submodule update/foreach/sync= apply.
  #+begin_src sh
    git submodule init /PATH/TO/SUBMODULE
  #+end_src
- Update one or all registered submodule(s).
  #+begin_src sh
    git submodule update [--init] [--checkout/rebase/merge] [--remote] [/PATH/TO/SUBMODULE]
  #+end_src
  where
  + =--init= performs =git submodule init= for each uninitialized submodule before update.
  + =--checkout/rebase/merge= indicates the behavior for the update.
    - =--checkout= is the default behavior, which checks out the commit recorded in the belonging repository on a detached HEAD in the submodule.
    - =--rebase= rebases the submodule's remote-tracking branch onto the commit recorded in the belonging repository.
    - =--merge= merges the commit recorded in the belonging repository into the submodule's remote-tracking branch.
  + =--remote= uses the status of the submodule's remote-tracking branch instead of the SHA-1 recorded in the belonging repository. In this case, its behavior is =--merge= in the last option, equivalent to run =git pull= in the target submodule(s).
- Show the status of a submodule. E.g., prefix =-= indicates an uninitialized submodule; prefix =+= means that the submodule commit currently checked out does not match the SHA-1 found in the index of the belonging repository; prefix =U= implies merge conflicts.
  #+begin_src sh
    git submodule status [/PATH/TO/SUBMODULE]
  #+end_src
- Unregister a registered submodule, i.e., remove the corresponding section from =.git/config= as well as the work tree. For a unregistered submodule, further calls to =git submodule update/foreach/sync= will skip.
  #+begin_src sh
    git submodule deinit [-f|--force] /PATH/TO/SUBMODULE
  #+end_src
  All the submodules can be unregistered by
  #+begin_src sh
    git submodule deinit [-f|--force] --all
  #+end_src
- Remove a submodule from the current repository.
  #+begin_src sh
    git submodule deinit -f /PATH/TO/SUBMODULE
    rm -fr .git/modules/PATH/TO/SUBMODULE
    git rm -f /PATH/TO/SUBMODULE
  #+end_src
- Evaluate an arbitrary shell command in each checked out submodule.
  #+begin_src sh
    git submodule foreach COMMAND
  #+end_src

* Footnotes

[fn:1] http://git-scm.com/book/en/v2
