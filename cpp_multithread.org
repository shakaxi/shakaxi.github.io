#+TITLE: C++ - Multithread

* 背景
C++98/03不支持多线程编程, 所以必须借助第三方库或目标操作系统中的多线程API. 这使得编写跨平台的多线程程序很困难. C++11引入了标准的多线程库, 使得多线程程序跨平台更加容易. 目前的C++11标准仅针对CPU, 不支持GPU.

多线程编程的难点之一是将算法并行化, 这个过程和算法的类型高度相关. 此外, 要防止竞争条件和死锁, 并考虑缓存的一致性.

- 竞争条件 :: 当多个线程要读/写共享内存位置时, 可能会发生竞争条件.
- 死锁 :: 线程因为等待另一个阻塞线程锁定的资源而造成的无限阻塞.
- 撕裂 :: 部分数据已写入内存, 但还有部分数据没有写入. 如果另一个线程在此时读取数据, 就会得到不一致的数据.
- 缓存的一致性 :: 如果一个线程写入了一段数据, 该线程会立即看到新数据, 但这并不意味着所有线程都会立即看到新数据. 所以, 在读写多个线程时, 即使是最简单的数据类型, 也需要同步.
* 线程
C++线程库定义在头文件 =<thread>= 中.
** 通过函数指针创建线程
标准C++的 =thread= 类的构造函数是一个可变参数模板, 可以接受任意数目的参数. 第一个参数为函数名称, 其余参数为函数的参数. 如
#+BEGIN_SRC C++
  #include <thread>

  using namespace std;

  void f(int i, int j, int k);
  thread t(f, 1, 2, 3);
#+END_SRC
默认情况下, 从不同线程中访问cout是线程安全的, 没有任何数据竞争, 除非在第一个输出或输入操作之前调用了 =cout.sync_with_stdio(false)=.
** 通过函数对象创建线程
使用函数指针技术, 向线程传递信息的唯一方式是向函数传递参数. 而使用函数对象, 可向函数对象类添加成员变量, 并可以采用任何方式初始化和使用这些变量. 如

