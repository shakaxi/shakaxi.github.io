#+TITLE: C++ - 标准库

本文是阅读 /Professional C++, third edition/ 中文版[fn:1]的读书笔记.

C++标准库的核心是泛型容器和泛型算法. 库中的这一子集称为标准模板库(Standard Template Library, STL), 因为这一部分大量使用了模板.

所有标准库类和函数都在 =std= 名称空间中声明. 包括如下组件:
- 字符串 :: 定义在头文件 =<string>= 中的 =string= 类.
- 正则表达式 :: 定义在头文件 =<regex>=.
- I/O流 :: 定义在头文件 =<fstream>=, =<iomanip>=, =<ios>=, =<iosfwd>=, =<iostream>=, =<istream>=, =<ostream>=, =<sstream>=, =<streambuf>= 和 =<strstream>= 中.
- 智能指针 :: 定义在头文件 =<memory>= 中的 =unique_ptr=, =shared_ptr=, =weak_ptr=.
- 异常 :: 定义在头文件 =<exception>=, =<stdexcept>= 和 =<system_error>=.
- 数学工具 ::
  + 定义在头文件 =<complex>= 中的复数类 =complex=.
  + 定义在头文件 =<ratio>= 中的有理数运算库.
  + 定义在头文件 =<valarray>= 中的 =valarray= 类(与 =vector= 类类似, 但是对高性能数值应用做了特别的优化).
  + 定义在头文件 =<limits>= 中的 =numeric_limits= 类模板, 如
    - =numeric_limits<int>::max()=
    - =numeric_limits<int>::min()=
    - =numeric_limits<int>::lowest()=
    - =numeric_limits<double>::max()=
    - =numeric_limits<double>::min()=
    - =numeric_limits<double>::lowest()=
- 时间工具 :: 定义在头文件 =<chrono>= 中的 =Chrono= 库.
- 随机数 :: 定义在头文件 =<random>= 中的随机数库.
- 初始化列表 :: 定义在头文件 =<initializer_list>= 中的初始化列表(用于编写参数数目可变的函数).
- =Pair= :: 定义在头文件 =<utility>= 中的 =pair= 模板, 用于存储两种不同类型的元素. 这称为存储异构元素.
- =Tuple= :: 定义在头文件 =<tuple>= 中的 =tuple= 是 =pair= 的一种泛化, 它是固定大小的序列, 元组的元素可以是异构的, 其实例化的元素数目和类型在编译时固定不变.
- 函数对象 :: 实现了函数调用运算符的类的对象称为函数对象. 函数对象可以用作某些STL算法的谓词. 头文件 =<functional>= 定义了一些预定义的函数对象, 支持根据已有的函数对象创建新函数对象.
- 多线程 ::
  + 单个线程可以用头文件 =<thread>= 中的 =thread= 类创建.
  + 定义在头文件 =<atomic>= 中的原子性提供了对一段数据的线程安全的原子访问.
  + =<condition_variable>= 和 =<mutex>= 提供了其他线程同步机制.
  + 如果只需计算某个数据得到结果, 并具有相应的异常处理, 使用定义在头文件 =<future>= 中的 =async= 和 =future= 要比直接使用 =thread= 类更容易.
- 类型特质 :: 定义在头文件 =<type_traits>= 中的类型特质提供了编译期间的类型信息. 编写高级模板时可以使用它.
- 标准模板库(STL) ::
  + 容器
    - STL中的所有容器都是模板, 是泛型结构, 因此可以通过这些容器保存任意类型的数据. 除 =array= 和 =bitset= 外, 大部分STL容器的大小灵活多变, 都能自动增长或收缩, 以容纳更多或者更少的元素.
    - STL容器是同构的, 每个容器实例只允许一种类型的元素.
    - 顺序容器(sequential container): 元素的序列.
      + =vector=
        - 定义在头文件 =<vector>= 中.
        - 提供对元素的随机访问.
        - 元素保存在连续的内存中.
        - 能够在尾部快速插入和删除元素, 在其他部位插入和删除操作比较慢.
        - 可以在本来需要使用数组的地方使用 =vector=.
        - 在任何可能的情况下使用 =vector= 而不是C风格的数组.
      + =list= (双向链表)
        - 定义在头文件 =<list>= 中.
        - 元素查找和访问很慢.
        - 元素不一定保存在连续的内存中.
        - 插入和删除很快.
      + =forward_list= (单向链表)
        - 只支持前向迭代.
        - 没有提供快速的随机访问.
        - 内存需求比 =list= 小.
      + =deque= (双头队列)
        - 定义在头文件 =<deque>= 中.
        - 提供了快速的元素访问.
        - 在序列两端提供了快速的插入和删除.
        - 在序列中间插入和删除的速度较慢.
      + =array=
        - 定义在头文件 =<array>= 中.
        - 标准C风格数组的替代品, 实际上是对C风格数组的简单包装.
        - 适合大小固定的集合.
        - 没有提供插入和删除操作.
        - 元素的访问速度极快.
    - 容器适配器 (adaptor): 只是构建在某种标准顺序容器上的简单接口.
      + =queue=
        - 定义在头文件 =<queue>= 中.
        - 提供了标准的先入先出(FIFO)语义.
        - 从一端插入元素, 从另一端取出元素.
        - 插入元素和删除元素都很快.
      + =priority_queue=
        - 定义在头文件 =<queue>= 中.
        - 插入删除比 =queue= 要慢.
      + =stack=
        - 定义在头文件 =<stack>= 中.
        - 提供了标准的先入后出(FILO)语义.
        - 最新插入的元素第一个被删除.
        - 提供了快速的元素插入和删除.
    - 关联容器: 关联了键和值
      + 排序关联容器或有序关联容器
        - =set= 和 =multiset=
        - =map= 和 =multimap=
      + 无序关联容器或哈希表(hash table)
        - =unordered_map= 和 =unordered_multimap=
        - =unordered_set= 和 =unordered_multiset=
    - 特殊容器: bitset
      + 定义在头文件 =<bitset>= 中.
      + 固定大小(声明时指定大小), 不支持迭代器.
  + 算法
    - 算法一般不属于容器的一部分. STL采取了一种分离数据(容器)和功能(算法)的方式. 正交性的指导原则使算法和容器分离开, (几乎)所有算法都可以用于(几乎)所有容器.
    - 泛型算法并不是直接对容器操作, 而是使用迭代器(iterator). 迭代器是算法和容器之间的中介, 提供了顺序遍历容器中的元素的标准接口, 因此任何算法都可以操作任何容器.
    - 定义在头文件 =<algorithm>= 中, 除非特别说明.
  + 不足
    - 在通过多线程同时访问容器时, STL不能保证任何线程安全.
    - STL没有提供任何泛型的树结构或图结构.

* Footnotes

[fn:1] Marc Gregoire著, 张永强译. C++高级编程(第3版), 清华大学出版社, 2015.
