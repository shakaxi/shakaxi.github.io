#+TITLE: C++ - 标准库

本文是阅读 /Professional C++, third edition/ 中文版[fn:1]的读书笔记.

C++标准库的核心是泛型容器和泛型算法. 库中的这一子集称为标准模板库(Standard Template Library, STL), 因为这一部分大量使用了模板.

所有标准库类和函数都在 =std= 名称空间中声明. 包括如下组件:
- 字符串 :: 定义在头文件 =<string>= 中的 =string= 类.
- 正则表达式 :: 定义在头文件 =<regex>=.
- I/O流 :: 定义在头文件 =<fstream>=, =<iomanip>=, =<ios>=, =<iosfwd>=, =<iostream>=, =<istream>=, =<ostream>=, =<sstream>=, =<streambuf>= 和 =<strstream>= 中.
- 智能指针 :: 定义在头文件 =<memory>= 中的 =unique_ptr=, =shared_ptr=, =weak_ptr=.
- 异常 :: 定义在头文件 =<exception>=, =<stdexcept>= 和 =<system_error>=.
- 数学工具 ::
  + 定义在头文件 =<complex>= 中的复数类 =complex=.
  + 定义在头文件 =<ratio>= 中的有理数运算库.
  + 定义在头文件 =<valarray>= 中的 =valarray= 类(与 =vector= 类类似, 但是对高性能数值应用做了特别的优化).
  + 定义在头文件 =<limits>= 中的 =numeric_limits= 类模板, 如
    - =numeric_limits<int>::max()=
    - =numeric_limits<int>::min()=
    - =numeric_limits<int>::lowest()=
    - =numeric_limits<double>::max()=
    - =numeric_limits<double>::min()=
    - =numeric_limits<double>::lowest()=
- 时间工具 :: 定义在头文件 =<chrono>= 中的 =Chrono= 库.
- 随机数 :: 定义在头文件 =<random>= 中的随机数库.
- 初始化列表 :: 定义在头文件 =<initializer_list>= 中的初始化列表(用于编写参数数目可变的函数).
- =Pair= :: 定义在头文件 =<utility>= 中的 =pair= 模板, 用于存储两种不同类型的元素. 这称为存储异构元素.
- =Tuple= :: 定义在头文件 =<tuple>= 中的 =tuple= 是 =pair= 的一种泛化, 它是固定大小的序列, 元组的元素可以是异构的, 其实例化的元素数目和类型在编译时固定不变.
- 函数对象 :: 实现了函数调用运算符的类的对象称为函数对象. 函数对象可以用作某些STL算法的谓词. 头文件 =<functional>= 定义了一些预定义的函数对象, 支持根据已有的函数对象创建新函数对象.
- 多线程 ::
  + 单个线程可以用头文件 =<thread>= 中的 =thread= 类创建.
  + 定义在头文件 =<atomic>= 中的原子性提供了对一段数据的线程安全的原子访问.
  + =<condition_variable>= 和 =<mutex>= 提供了其他线程同步机制.
  + 如果只需计算某个数据得到结果, 并具有相应的异常处理, 使用定义在头文件 =<future>= 中的 =async= 和 =future= 要比直接使用 =thread= 类更容易.
- 类型特质 :: 定义在头文件 =<type_traits>= 中的类型特质提供了编译期间的类型信息. 编写高级模板时可以使用它.
- 标准模板库(STL) ::
  + 容器
    - STL中的所有容器都是模板, 是泛型结构, 因此可以通过这些容器保存任意类型的数据. 除 =array= 和 =bitset= 外, 大部分STL容器的大小灵活多变, 都能自动增长或收缩, 以容纳更多或者更少的元素.
    - STL容器是同构的, 每个容器实例只允许一种类型的元素.
    - STL容器对元素使用值语义(value semantic)。因此，编写要用于STL的类时，一定要保证它们是可复制的。如果需要引用语义，必须自己实现。实现方法是保存元素指针，而不是保存元素本身。可以使用 =unique_ptr=, 使容器成为该指针所指对象的拥有者；或者使用 =shared_ptr=, 使容器与其他拥有者共享拥有权。
    - STL容器的一个模板类型参数是分配器(allocator)。该容器可以使用该分配器来为元素分配内存或释放内存。有些容器(例如 =map=)也接受将一个比较器(comparator)作为一个模板类型参数。比较器用作顺序元素。
    - 移动语义要正确地用于STL容器，必须把移动构造函数和移动复制运算符标记为 =noexcept=.
    - 顺序容器(sequential container): 元素的序列.
      + =vector=
        - 定义在头文件 =<vector>= 中.
        - 提供对元素的随机访问.
        - 元素保存在连续的内存中.
        - 能够在尾部快速插入和删除元素, 在其他部位插入和删除操作比较慢.
        - 可以在本来需要使用数组的地方使用 =vector=.
        - 在任何可能的情况下使用 =vector= 而不是C风格的数组.
        - =vector= 的默认构造函数会创建一个带有0个元素的 =vector=. 此外, 还提供了一个可以指定元素数量的构造函数, 和同时指定元素数目和元素值的构造函数. 如果没有提供默认值, 那么新对象通过0初始化——将原始的整型类型初始化为0, 将原始浮点类型初始化为0.0, 将指针类型初始化为 =nullptr=.
        - =vector= 的 =operator[]= 没有提供边界检查功能. C++标准指出通过 =operator[]= 访问边界外元素得到的结果是未定义的. 不同的是, =at()= 方法会执行边界检查, 越界会抛出异常(=out_of_range=).
        - =front()= 和 =back()= 分别返回 =vector= 的第一个元素和最后一个元素的引用.
        - =size()= 返回容器中元素的数目.
      + =list= (双向链表)
        - 定义在头文件 =<list>= 中.
        - 元素查找和访问很慢.
        - 元素不一定保存在连续的内存中.
        - 插入和删除很快.
      + =forward_list= (单向链表)
        - 只支持前向迭代.
        - 没有提供快速的随机访问.
        - 内存需求比 =list= 小.
      + =deque= (双头队列)
        - 定义在头文件 =<deque>= 中.
        - 提供了快速的元素访问.
        - 在序列两端提供了快速的插入和删除.
        - 在序列中间插入和删除的速度较慢.
      + =array=
        - 定义在头文件 =<array>= 中.
        - 标准C风格数组的替代品, 实际上是对C风格数组的简单包装.
        - 适合大小固定的集合.
        - 没有提供插入和删除操作.
        - 元素的访问速度极快.
    - 容器适配器(adaptor): 只是构建在某种标准顺序容器上的简单接口.
      + =queue=
        - 定义在头文件 =<queue>= 中.
        - 提供了标准的先入先出(FIFO)语义.
        - 从一端插入元素, 从另一端取出元素.
        - 插入元素和删除元素都很快.
      + =priority_queue=
        - 定义在头文件 =<queue>= 中.
        - 插入删除比 =queue= 要慢.
      + =stack=
        - 定义在头文件 =<stack>= 中.
        - 提供了标准的先入后出(FILO)语义.
        - 最新插入的元素第一个被删除.
        - 提供了快速的元素插入和删除.
    - 关联容器: 关联了键和值
      + 排序关联容器或有序关联容器
        - =set= 和 =multiset=
        - =map= 和 =multimap=
      + 无序关联容器或哈希表(hash table)
        - =unordered_map= 和 =unordered_multimap=
        - =unordered_set= 和 =unordered_multiset=
    - 特殊容器: =bitset=
      + 定义在头文件 =<bitset>= 中.
      + 固定大小(声明时指定大小), 不支持迭代器.
  + 算法
    - 定义在头文件 =<algorithm>= 中, 除非特别说明.
    - 算法一般不属于容器的一部分. STL采取了一种分离数据(容器)和功能(算法)的方式. 正交性的指导原则使算法和容器分离开, (几乎)所有算法都可以用于(几乎)所有容器.
    - 泛型算法并不是直接对容器操作, 而是使用迭代器(iterator). 迭代器是算法和容器之间的中介, 提供了顺序遍历容器中的元素的标准接口, 因此任何算法都可以操作任何容器.
  + 迭代器
    - STL通过迭代器模式提供了访问容器元素的泛型抽象。每个容器都提供了容器特定的迭代器，迭代器实际上是增强版的智能指针，这种指针知道如何遍历特定容器的元素，所有不同容器的迭代器都遵循C++标准中定义的特定接口。
    - 迭代器的实现类似于智能指针类，因为它们都重载了特定的运算符。基本的迭代器操作类似于普通指针(dumb pointer)支持的操作，因此普通指针可以合法用作特定容器的迭代器。可以将迭代器想象为指向容器中某个元素的指针。与指向数组元素的指针一样，迭代器可以通过 =operator++= 移动到下一个元素。还可以在迭代器上使用 =operator*= 和 =operator->= 来访问实际元素或元素中的字段。有些迭代器支持通过 =operator=== 和 =operator!== 进行比较，还支持通过 =operator--= 转移到前一个元素。
    - 所有迭代器都必须可以通过复制来构建，赋值，且可以析构。
    - 可以使用 =std::distance()= 计算容器的两个迭代器之差。
    - 只有顺序容器，关联容器和无序关联容器提供了迭代器，容器适配器和 =bitset= 类都不支持迭代元素。
    - STL中每个支持迭代器的容器类都为其迭代器类型提供了名为 =iterator= 和 =const_iterator= 的公共 =typedef= 。允许反向迭代元素的容器还提供了名为 =reverse_iterator= 和 =const_reverse_iterator= 的公共 =typedef= 。其中， =const_iterator= 和 =const_reverse_iterator= 提供了容器元素的只读访问。
    - 容器的 =begin()= 方法返回容器中第一个元素的迭代器, =end()= 方法返回的迭代器是在容器中最后一个元素的迭代器上执行 =operator++= 后的结果. =begin()= 和 =end()= 在一起提供了一个左开右闭区间——包含第一个元素却不包含最后一个元素. 采用这种方式的原因是为了支持空容器——不包含任何元素的容器, 此时 =begin()= 等于 =end()=. 类似的还有返回 =const= 迭代器的 =cbegin()= 和 =cend()= 方法, 返回反向迭代器的 =rbegin()= 和 =rend()= 方法, 以及返回 =const= 反向迭代器的 =crbegin()= 和 =crend()= 方法. 标准库还支持全局非成员函数 =std::begin()= 和 =std::end()=, C++14又添加了 =std::cbegin()=, =std::cend=, =std::rbegin()=, =std::rend()=, =std::crbegin()=, =std::crend()=. 建议使用这些非成员函数, 而不是其成员函数.
  + 不足
    - 在通过多线程同时访问容器时, STL不能保证任何线程安全.
    - STL没有提供任何泛型的树结构或图结构.

* Footnotes

[fn:1] Marc Gregoire著, 张永强译. C++高级编程(第3版), 清华大学出版社, 2015.
