#+TITLE: Linux - Bash

* Running ways
- Make the shell script executable :: The script should begin with the shebang (e.g. =#!/bin/bash=).
- Treat the shell script as the argument of =sh= :: In this case, the shebang is not necessary.
* Print
** =echo=
- By default, a line break is appended every time it is invoked.
- The default line break can be avoided by option =-n=.
** =printf=
- Syntax
#+BEGIN_SRC sh
printf "format_list" content/variable_list
#+END_SRC
- Format
  + =%s=
    - =%3s=: 3-character wide and right alignment.
    - =%-3s=: 3-character wide and left alignment.
  + =%c=
  + =\n=: line break.
  + =%f=
    - =%5.2f=: 5-character wide with 2 of them for decimal portion, right alignment.
    - =%-5.2f=: 5-character wide with 2 of them for decimal portion, left alignment.
* Variable
In Bash, every variable is a string.
** Plain variable
Assignment
#+BEGIN_SRC sh
var_name=var_value
#+END_SRC
** Environment variable
*** List
#+BEGIN_SRC sh
cat /proc/$PID/environ
#+END_SRC
where =$PID= is an integer and can be obtained by =pgrep=, e.g.
#+BEGIN_SRC sh
pgrep emacs
#+END_SRC
*** Assignment
#+BEGIN_SRC sh
env_var_name=value
export env_var_name
...
export env_var_name=value
#+END_SRC
- =$SHELL= or =$0=
- =$UID=
- =$?= indicates the exit state of last command.
  + *0* means successfully executed
  + *Others* mean failure
*** Get the length of variable's value (string)
#+BEGIN_SRC sh
${#var_name}
#+END_SRC
** Mathematical operation (e.g. =let=)
=$= in front of variable name is not needed.
#+BEGIN_SRC sh
let var=var1+var2
...
let var++
let var+=1
let var=var+1
...
let var--
let var-=1
let var=var-1
#+END_SRC
* Array
#+BEGIN_SRC sh
array_var=(0, 1, 2, 3, 6)
...
echo #{array_var[0]}
#+END_SRC
* Alias
#+BEGIN_SRC sh
alias new_command='command sequence'
...
new_command
#+END_SRC
* Function
#+BEGIN_SRC sh
function func_name()
{
statements
}
...
func_name()
{
statements
}
...
func_name arg_list
#+END_SRC
- =$0=: script name.
- =$n=: the =n=-th argument, n=1, 2, ...
- =$@=: "$1" "$2" "$3"
- =$*=: "$1c$2c$3", where =c= is the 1st character of /IFS/.
* Test & comparison
** Arithmetic
#+BEGIN_SRC sh
[ $var -eq 0 ]
[ $var -ne 0 ]
[ $var -gt 0 ]
[ $var -ge 0 ]
[ $var -lt 0 ]
[ $var -le 0 ]
[ $var1 -ne 0 -a $var2 -lt 1 ]
[ $var1 -ne 0 -o $var2 -lt 1 ]
#+END_SRC
** File system
#+BEGIN_SRC sh
[ -f $var ] # is $var a file?
[ -d $var ] # is $var a directory?
[ -x $var ] # is $var executable?
[ -e $var ] # does $var exist?
[ -w $var ] # is $var writable?
[ -r $var ] # is $var readable?
[ -L $var ] # is $var a symbolic link?
[ -b $var ] # is $var a block device?
[ -c $var ] # is $var a character device?
#+END_SRC
** String
#+BEGIN_SRC sh
[[ -z $str ]] # is $str an empty string?
[[ -n $str ]] # is $str a non-empty string?
[[ $str1==$str2 ]]
[[ $str1!=$str2 ]]
[[ $str1>$str2 ]]
[[ $str1<$str2 ]]
[[ -n $str1 ]] && [[ -z $str2 ]]
[[ -n $str1 ]] || [[ -z $str2 ]]
#+END_SRC
* Judgement
#+BEGIN_SRC sh
if condition; then
commands
fi
...
[ condition ] && command
...
[ condition ] || command
...
if condition; then
commands1
else
commands2
fi
...
if condition1; then
commands1
elif condition2; then
commands2
else
commands3
fi
#+END_SRC
* Iteration
#+BEGIN_SRC sh
for var in list;
do
commands # use $var
done
...
while condition
do
commands # use $var
done
...
until condition
do
commands # use $var
done
#+END_SRC
* Miscellaneous
- Commands are seperated by semicolon (;) or line break.
- /File descriptor/ is an abstract pointer for file access.
- Internal field separator (IFS)
  + =$IFS= is the environment variable to store IFS.
  + Default values: space, table, line break.
